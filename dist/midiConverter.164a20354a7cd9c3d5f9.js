!function(g){var I={};function C(A){if(I[A])return I[A].exports;var n=I[A]={i:A,l:!1,exports:{}};return g[A].call(n.exports,n,n.exports,C),n.l=!0,n.exports}C.m=g,C.c=I,C.d=function(g,I,A){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:A})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var n in g)C.d(A,n,function(I){return g[I]}.bind(null,n));return A},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=0)}([function(module,exports){eval("console.log('hello');\n\n// TODO: Send the error string in postMessage\n\nonmessage = (message) => {\n    const { wadId, lumpId, data } = message.data;\n\n    console.log(`Converting '${lumpId}' from MUS to MIDI (WAD: '${wadId}') ...`);\n\n    // MUS event codes\n    const mus_releasekey = 0x00;\n    const mus_presskey = 0x10;\n    const mus_pitchwheel = 0x20;\n    const mus_systemevent = 0x30;\n    const mus_changecontroller = 0x40;\n    const mus_scoreend = 0x60;\n\n    // MIDI event codes\n    const midi_releasekey = 0x80;\n    const midi_presskey = 0x90;\n    const midi_aftertouchkey = 0xA0;\n    const midi_changecontroller = 0xB0;\n    const midi_changepatch = 0xC0;\n    const midi_aftertouchchannel = 0xD0;\n    const midi_pitchwheel = 0xE0;\n\n    // Structure to hold MUS file header\n    const musheader = {\n        id: [],\n        scorelength: null,\n        scorestart: null,\n        primarychannels: null,\n        secondarychannels: null,\n        instrumentcount: null,\n    };\n\n    // Standard MIDI type 0 header + track header\n    /*\n    const uint8_t midiheader[] =\n    {\n        'M', 'T', 'h', 'd',     // Main header\n        0x00, 0x00, 0x00, 0x06, // Header size\n        0x00, 0x00,             // MIDI type (0)\n        0x00, 0x01,             // Number of tracks\n        0x00, 0x46,             // Resolution\n        'M', 'T', 'r', 'k',     // Start of track\n        0x00, 0x00, 0x00, 0x00  // Placeholder for track length\n    };\n    */\n    // ^ this is the standard first 22 bytes of the midi output, aside from adding the track length.\n    // I should create a function that adds this data manually with the DataView\n    function writeMidiHeader() {\n        const midiHeaderData = ['M'.charCodeAt(0), 'T'.charCodeAt(0), 'h'.charCodeAt(0), 'd'.charCodeAt(0), // Main header\n            0x00, 0x00, 0x00, 0x06, // Header size\n            0x00, 0x00, // MIDI type (0)\n            0x00, 0x01, // Number of tracks\n            0x00, 0x46, // Resolution\n        'M'.charCodeAt(0), 'T'.charCodeAt(0), 'r'.charCodeAt(0), 'k'.charCodeAt(0), // Start of track\n            0x00, 0x00, 0x00, 0x00, // Placeholder for track length\n        ];\n\n        writeData(midiHeaderData);\n    }\n\n    let musDataView;\n    let musDataPosition;\n\n    // Constants\n    const NUM_CHANNELS = 16;\n    const MUS_PERCUSSION_CHAN = 15;\n    const MIDI_PERCUSSION_CHAN = 9;\n    const MIDI_TRACKLENGTH_OFS = 18;\n\n    // Cached channel velocities\n    const channelvelocities = [127, 127, 127, 127, 127, 127, 127, 127,\n        127, 127, 127, 127, 127, 127, 127, 127];\n\n    // Timestamps between sequences of MUS events\n    let queuedtime = 0;\n\n    // Counter for the length of the track\n    let tracksize;\n\n    const controller_map = [0x00, 0x20, 0x01, 0x07, 0x0A, 0x0B, 0x5B, 0x5D,\n        0x40, 0x43, 0x78, 0x7B, 0x7E, 0x7F, 0x79];\n\n    const channel_map = [];\n\n    // Main DataView for writing to. This is used by writeData();\n    let outputDataView;\n\n    // Wrapper function to work like slade's memchunk.write()\n    // I'm so lazy\n    let position = 0;\n    let dataToWrite = [];\n    function writeData(bytes) {\n        dataToWrite = dataToWrite.concat(bytes);\n    }\n\n    function confirmWrite() {\n        const newBuffer = new ArrayBuffer(dataToWrite.length);\n        outputDataView = new DataView(newBuffer);\n        // Then write the data\n        for (let i = 0; i < dataToWrite.length; i++) {\n            outputDataView.setUint8(position, dataToWrite[i]);\n            position += 1;\n        }\n    }\n\n    // Write timestamp to a MIDI file.\n    function writeTime(time) {\n        let buffer = time & 0x7F;\n        let writeval;\n\n        while ((time >>= 7) != 0) {\n            buffer <<= 8;\n            buffer |= ((time & 0x7F) | 0x80);\n        }\n\n        for (; ;) {\n            writeval = (buffer & 0xFF);\n\n            writeData([writeval]);\n\n            tracksize += 1;\n\n            if ((buffer & 0x80) != 0) { buffer >>= 8; } else {\n                queuedtime = 0;\n                return;\n            }\n        }\n    }\n\n    // Write the end of track marker\n    function writeEndTrack() {\n        const endtrack = [0xFF, 0x2F, 0x00];\n\n        writeTime(queuedtime);\n\n        writeData(endtrack);\n\n        tracksize += 3;\n    }\n\n    // Write a key press event\n    function writePressKey(channel, key, velocity) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        // Write pressed key and channel\n        let working = midi_presskey | channel;\n        writeData([working]);\n\n        // Write key\n        working = key & 0x7F;\n        writeData([working]);\n\n        // Wite velocity\n        working = velocity & 0x7F;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a key release event\n    function writeReleaseKey(channel, key) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        // Write released key\n        let working = midi_releasekey | channel;\n        writeData([working]);\n\n        // Write key\n        working = key & 0x7F;\n        writeData([working]);\n\n        // Dummy\n        working = 0;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a pitch wheel/bend event\n    function writePitchWheel(channel, wheel) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = midi_pitchwheel | channel;\n        writeData([working]);\n\n        working = wheel & 0x7F;\n        writeData([working]);\n\n        working = (wheel >> 7) & 0x7F;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a patch change event\n    function writeChangePatch(channel, patch) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = midi_changepatch | channel;\n        writeData([working]);\n\n        working = patch & 0x7F;\n        writeData([working]);\n\n        tracksize += 2;\n    }\n\n    // Write a valued controller change event\n    function writeChangeController_Valued(channel, control, value) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = midi_changecontroller | channel;\n        writeData([working]);\n\n        working = control & 0x7F;\n        writeData([working]);\n\n        // Quirk in vanilla DOOM? MUS controller values should be 7-bit, not 8-bit.\n        working = value & 0x80 ? 0x7F : value;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a valueless controller change event\n    function writeChangeController_Valueless(channel, control) {\n        writeChangeController_Valued(channel, control, 0);\n    }\n\n    // Allocate a free MIDI channel.\n    function allocateMIDIChannel() {\n        let result;\n        let max;\n        let i;\n\n        // Find the current highest-allocated channel.\n\n        max = -1;\n\n        for (i = 0; i < NUM_CHANNELS; ++i) {\n            if (channel_map[i] > max) {\n                max = channel_map[i];\n            }\n        }\n\n        // max is now equal to the highest-allocated MIDI channel.  We can\n        // now allocate the next available channel.  This also works if\n        // no channels are currently allocated (max=-1)\n\n        result = max + 1;\n\n        // Don't allocate the MIDI percussion channel!\n\n        if (result === MIDI_PERCUSSION_CHAN) {\n            ++result;\n        }\n\n        return result;\n    }\n\n    // Given a MUS channel number, get the MIDI channel number to use in the outputted file.\n    function getMIDIChannel(mus_channel) {\n        // Find the MIDI channel to use for this MUS channel.\n        // MUS channel 15 is the percusssion channel.\n\n        if (mus_channel === MUS_PERCUSSION_CHAN) {\n            return MIDI_PERCUSSION_CHAN;\n        }\n\n        // If a MIDI channel hasn't been allocated for this MUS channel\n        // yet, allocate the next free MIDI channel.\n\n        if (channel_map[mus_channel] === -1) {\n            channel_map[mus_channel] = allocateMIDIChannel();\n        }\n\n        return channel_map[mus_channel];\n    }\n\n    function readMusHeader(dataView) {\n        const output = Object.create(musheader);\n\n        for (let i = 0; i < 4; i++) {\n            output.id.push(dataView.getUint8(i));\n        }\n        output.scorelength = dataView.getUint16(4, true);\n        output.scorestart = dataView.getUint16(6, true);\n        output.primarychannels = dataView.getUint16(8, true);\n        output.secondarychannels = dataView.getUint16(10, true);\n        output.instrumentcount = dataView.getUint16(12, true);\n\n        return output;\n    }\n\n    function convertMusToMidi(musinput) {\n        // master dataview for input mus\n        musDataView = musinput;\n        musDataPosition = 0;\n        const startTime = Date.now();\n\n        function getMusByte8() {\n            const output = musDataView.getUint8(musDataPosition);\n            musDataPosition += 1;\n            // console.log(output);\n            return output;\n        }\n\n        // master data for output midi\n        const outputArrayBuffer = new ArrayBuffer(0);\n        outputDataView = new DataView(outputArrayBuffer);\n\n        // Descriptor for the current MUS event\n        let eventdescriptor;\n        let channel; // Channel number\n        let mus_event;\n\n\n        // Bunch of vars read from MUS lump\n        let key;\n        let controllernumber;\n        let controllervalue;\n\n        // Flag for when the score end marker is hit.\n        let hitscoreend = 0;\n\n        // Temp working byte\n        let working;\n        // Used in building up time delays\n        let timedelay;\n\n        // Initialise channel map to mark all channels as unused.\n        for (channel = 0; channel < NUM_CHANNELS; ++channel) {\n            channel_map[channel] = -1;\n        }\n\n        // Grab the header\n        const musfileheader = readMusHeader(musDataView);\n        // Check MUS header\n        if (musfileheader.id[0] !== 'M'.charCodeAt(0) || musfileheader.id[1] !== 'U'.charCodeAt(0)\n            || musfileheader.id[2] !== 'S'.charCodeAt(0) || musfileheader.id[3] !== 0x1A) {\n            console.error('Invalid MUS header.');\n            return false;\n        }\n\n        // Seek to where the data is held\n        musDataPosition = musfileheader.scorestart;\n        // So, we can assume the MUS file is faintly legit. Let's start writing MIDI data...\n\n        writeMidiHeader();\n        tracksize = 0;\n\n        // Now, process the MUS file:\n        while (hitscoreend === 0) {\n            // Handle a block of events:\n\n            while (hitscoreend === 0) {\n                // Fetch channel number and event code:\n                eventdescriptor = getMusByte8();\n\n\n                channel = getMIDIChannel(eventdescriptor & 0x0F);\n                mus_event = eventdescriptor & 0x70;\n                switch (mus_event) {\n                    case mus_releasekey:\n                        // console.log('mus_releasekey');\n                        key = getMusByte8();\n\n                        writeReleaseKey(channel, key);\n\n                        break;\n\n                    case mus_presskey:\n                        key = getMusByte8();\n\n                        if (key & 0x80) {\n                            channelvelocities[channel] = getMusByte8();\n\n                            channelvelocities[channel] &= 0x7F;\n\n                            // console.log('mus_presskey: '+key+ ' ' + channelvelocities[channel]);\n                        } else {\n                            // console.log('mus_presskey: '+key);\n                        }\n\n                        writePressKey(channel, key, channelvelocities[channel]);\n\n                        break;\n\n                    case mus_pitchwheel:\n                        // console.log('mus_pitchwheel');\n                        key = getMusByte8();\n\n                        writePitchWheel(channel, key * 64);\n\n                        break;\n\n                    case mus_systemevent:\n                        // console.log('mus_systemevent');\n                        controllernumber = getMusByte8();\n\n                        if (controllernumber < 10 || controllernumber > 14) {\n                            console.error(`Controller number inaccurate 10-14: ${controllernumber}`);\n                            return false;\n                        }\n\n                        writeChangeController_Valueless(channel, controller_map[controllernumber]);\n\n                        break;\n\n                    case mus_changecontroller:\n                        controllernumber = getMusByte8();\n                        controllervalue = getMusByte8();\n                        // console.log('mus_changecontroller: ' +controllernumber+' '+controllervalue);\n                        if (controllernumber == 0) {\n                            writeChangePatch(channel, controllervalue);\n                        } else {\n                            if (controllernumber < 1 || controllernumber > 9) {\n                                console.error(`Controller number inaccurate: ${controllernumber}`);\n                                return false;\n                            }\n\n                            writeChangeController_Valued(channel, controller_map[controllernumber], controllervalue);\n                        }\n\n                        break;\n\n                    case mus_scoreend:\n                        // console.log('mus_scoreend');\n                        hitscoreend = 1;\n                        break;\n\n                    default:\n                        // console.log('eventdescriptor default: '+eventdescriptor + ' ' + (eventdescriptor & 0x80));\n                        return false;\n                }\n                if ((eventdescriptor & 0x80) != 0) {\n                    // console.log('delay count');\n                    break;\n                }\n            }\n            // Now we need to read the time code:\n            if (hitscoreend === 0) {\n                // console.log('read time code');\n                timedelay = 0;\n                // delayCounter = 0;\n                for (; ;) {\n                    working = getMusByte8();\n                    // delayCounter += 1;\n                    timedelay = timedelay * 128 + (working & 0x7F);\n                    if ((working & 0x80) == 0) { break; }\n                }\n                // console.log('delay count: '+delayCounter + ' time delay: ' + timedelay)\n                queuedtime += timedelay;\n            }\n        }\n        console.log(`Converted '${lumpId}' from MUS to MIDI (WAD: '${wadId}').`);\n        // End of track\n        writeEndTrack();\n\n        confirmWrite();\n\n        // Write the track size into the stream\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 0, (tracksize >> 24) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 1, (tracksize >> 16) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 2, (tracksize >> 8) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 3, tracksize & 0xff);\n\n        return outputDataView.buffer;\n    }\n\n    const masterOutput = convertMusToMidi(data);\n    if (masterOutput === false) {\n        console.error(`Failed to convert '${lumpId}' from MUS to MIDI  (WAD: '${wadId}').`, { musDataPosition });\n    }\n\n    postMessage({\n        status: 'done',\n        wadId,\n        lumpId,\n        midi: masterOutput,\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC93b3JrZXJzL21pZGlDb252ZXJ0ZXIuanM/Mjk5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxvZygnaGVsbG8nKTtcblxuLy8gVE9ETzogU2VuZCB0aGUgZXJyb3Igc3RyaW5nIGluIHBvc3RNZXNzYWdlXG5cbm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgeyB3YWRJZCwgbHVtcElkLCBkYXRhIH0gPSBtZXNzYWdlLmRhdGE7XG5cbiAgICBjb25zb2xlLmxvZyhgQ29udmVydGluZyAnJHtsdW1wSWR9JyBmcm9tIE1VUyB0byBNSURJIChXQUQ6ICcke3dhZElkfScpIC4uLmApO1xuXG4gICAgLy8gTVVTIGV2ZW50IGNvZGVzXG4gICAgY29uc3QgbXVzX3JlbGVhc2VrZXkgPSAweDAwO1xuICAgIGNvbnN0IG11c19wcmVzc2tleSA9IDB4MTA7XG4gICAgY29uc3QgbXVzX3BpdGNod2hlZWwgPSAweDIwO1xuICAgIGNvbnN0IG11c19zeXN0ZW1ldmVudCA9IDB4MzA7XG4gICAgY29uc3QgbXVzX2NoYW5nZWNvbnRyb2xsZXIgPSAweDQwO1xuICAgIGNvbnN0IG11c19zY29yZWVuZCA9IDB4NjA7XG5cbiAgICAvLyBNSURJIGV2ZW50IGNvZGVzXG4gICAgY29uc3QgbWlkaV9yZWxlYXNla2V5ID0gMHg4MDtcbiAgICBjb25zdCBtaWRpX3ByZXNza2V5ID0gMHg5MDtcbiAgICBjb25zdCBtaWRpX2FmdGVydG91Y2hrZXkgPSAweEEwO1xuICAgIGNvbnN0IG1pZGlfY2hhbmdlY29udHJvbGxlciA9IDB4QjA7XG4gICAgY29uc3QgbWlkaV9jaGFuZ2VwYXRjaCA9IDB4QzA7XG4gICAgY29uc3QgbWlkaV9hZnRlcnRvdWNoY2hhbm5lbCA9IDB4RDA7XG4gICAgY29uc3QgbWlkaV9waXRjaHdoZWVsID0gMHhFMDtcblxuICAgIC8vIFN0cnVjdHVyZSB0byBob2xkIE1VUyBmaWxlIGhlYWRlclxuICAgIGNvbnN0IG11c2hlYWRlciA9IHtcbiAgICAgICAgaWQ6IFtdLFxuICAgICAgICBzY29yZWxlbmd0aDogbnVsbCxcbiAgICAgICAgc2NvcmVzdGFydDogbnVsbCxcbiAgICAgICAgcHJpbWFyeWNoYW5uZWxzOiBudWxsLFxuICAgICAgICBzZWNvbmRhcnljaGFubmVsczogbnVsbCxcbiAgICAgICAgaW5zdHJ1bWVudGNvdW50OiBudWxsLFxuICAgIH07XG5cbiAgICAvLyBTdGFuZGFyZCBNSURJIHR5cGUgMCBoZWFkZXIgKyB0cmFjayBoZWFkZXJcbiAgICAvKlxuICAgIGNvbnN0IHVpbnQ4X3QgbWlkaWhlYWRlcltdID1cbiAgICB7XG4gICAgICAgICdNJywgJ1QnLCAnaCcsICdkJywgICAgIC8vIE1haW4gaGVhZGVyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDYsIC8vIEhlYWRlciBzaXplXG4gICAgICAgIDB4MDAsIDB4MDAsICAgICAgICAgICAgIC8vIE1JREkgdHlwZSAoMClcbiAgICAgICAgMHgwMCwgMHgwMSwgICAgICAgICAgICAgLy8gTnVtYmVyIG9mIHRyYWNrc1xuICAgICAgICAweDAwLCAweDQ2LCAgICAgICAgICAgICAvLyBSZXNvbHV0aW9uXG4gICAgICAgICdNJywgJ1QnLCAncicsICdrJywgICAgIC8vIFN0YXJ0IG9mIHRyYWNrXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgIC8vIFBsYWNlaG9sZGVyIGZvciB0cmFjayBsZW5ndGhcbiAgICB9O1xuICAgICovXG4gICAgLy8gXiB0aGlzIGlzIHRoZSBzdGFuZGFyZCBmaXJzdCAyMiBieXRlcyBvZiB0aGUgbWlkaSBvdXRwdXQsIGFzaWRlIGZyb20gYWRkaW5nIHRoZSB0cmFjayBsZW5ndGguXG4gICAgLy8gSSBzaG91bGQgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBhZGRzIHRoaXMgZGF0YSBtYW51YWxseSB3aXRoIHRoZSBEYXRhVmlld1xuICAgIGZ1bmN0aW9uIHdyaXRlTWlkaUhlYWRlcigpIHtcbiAgICAgICAgY29uc3QgbWlkaUhlYWRlckRhdGEgPSBbJ00nLmNoYXJDb2RlQXQoMCksICdUJy5jaGFyQ29kZUF0KDApLCAnaCcuY2hhckNvZGVBdCgwKSwgJ2QnLmNoYXJDb2RlQXQoMCksIC8vIE1haW4gaGVhZGVyXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDA2LCAvLyBIZWFkZXIgc2l6ZVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgLy8gTUlESSB0eXBlICgwKVxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgLy8gTnVtYmVyIG9mIHRyYWNrc1xuICAgICAgICAgICAgMHgwMCwgMHg0NiwgLy8gUmVzb2x1dGlvblxuICAgICAgICAnTScuY2hhckNvZGVBdCgwKSwgJ1QnLmNoYXJDb2RlQXQoMCksICdyJy5jaGFyQ29kZUF0KDApLCAnaycuY2hhckNvZGVBdCgwKSwgLy8gU3RhcnQgb2YgdHJhY2tcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIFBsYWNlaG9sZGVyIGZvciB0cmFjayBsZW5ndGhcbiAgICAgICAgXTtcblxuICAgICAgICB3cml0ZURhdGEobWlkaUhlYWRlckRhdGEpO1xuICAgIH1cblxuICAgIGxldCBtdXNEYXRhVmlldztcbiAgICBsZXQgbXVzRGF0YVBvc2l0aW9uO1xuXG4gICAgLy8gQ29uc3RhbnRzXG4gICAgY29uc3QgTlVNX0NIQU5ORUxTID0gMTY7XG4gICAgY29uc3QgTVVTX1BFUkNVU1NJT05fQ0hBTiA9IDE1O1xuICAgIGNvbnN0IE1JRElfUEVSQ1VTU0lPTl9DSEFOID0gOTtcbiAgICBjb25zdCBNSURJX1RSQUNLTEVOR1RIX09GUyA9IDE4O1xuXG4gICAgLy8gQ2FjaGVkIGNoYW5uZWwgdmVsb2NpdGllc1xuICAgIGNvbnN0IGNoYW5uZWx2ZWxvY2l0aWVzID0gWzEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LFxuICAgICAgICAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyN107XG5cbiAgICAvLyBUaW1lc3RhbXBzIGJldHdlZW4gc2VxdWVuY2VzIG9mIE1VUyBldmVudHNcbiAgICBsZXQgcXVldWVkdGltZSA9IDA7XG5cbiAgICAvLyBDb3VudGVyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSB0cmFja1xuICAgIGxldCB0cmFja3NpemU7XG5cbiAgICBjb25zdCBjb250cm9sbGVyX21hcCA9IFsweDAwLCAweDIwLCAweDAxLCAweDA3LCAweDBBLCAweDBCLCAweDVCLCAweDVELFxuICAgICAgICAweDQwLCAweDQzLCAweDc4LCAweDdCLCAweDdFLCAweDdGLCAweDc5XTtcblxuICAgIGNvbnN0IGNoYW5uZWxfbWFwID0gW107XG5cbiAgICAvLyBNYWluIERhdGFWaWV3IGZvciB3cml0aW5nIHRvLiBUaGlzIGlzIHVzZWQgYnkgd3JpdGVEYXRhKCk7XG4gICAgbGV0IG91dHB1dERhdGFWaWV3O1xuXG4gICAgLy8gV3JhcHBlciBmdW5jdGlvbiB0byB3b3JrIGxpa2Ugc2xhZGUncyBtZW1jaHVuay53cml0ZSgpXG4gICAgLy8gSSdtIHNvIGxhenlcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgIGxldCBkYXRhVG9Xcml0ZSA9IFtdO1xuICAgIGZ1bmN0aW9uIHdyaXRlRGF0YShieXRlcykge1xuICAgICAgICBkYXRhVG9Xcml0ZSA9IGRhdGFUb1dyaXRlLmNvbmNhdChieXRlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlybVdyaXRlKCkge1xuICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVRvV3JpdGUubGVuZ3RoKTtcbiAgICAgICAgb3V0cHV0RGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcobmV3QnVmZmVyKTtcbiAgICAgICAgLy8gVGhlbiB3cml0ZSB0aGUgZGF0YVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFUb1dyaXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChwb3NpdGlvbiwgZGF0YVRvV3JpdGVbaV0pO1xuICAgICAgICAgICAgcG9zaXRpb24gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdyaXRlIHRpbWVzdGFtcCB0byBhIE1JREkgZmlsZS5cbiAgICBmdW5jdGlvbiB3cml0ZVRpbWUodGltZSkge1xuICAgICAgICBsZXQgYnVmZmVyID0gdGltZSAmIDB4N0Y7XG4gICAgICAgIGxldCB3cml0ZXZhbDtcblxuICAgICAgICB3aGlsZSAoKHRpbWUgPj49IDcpICE9IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA8PD0gODtcbiAgICAgICAgICAgIGJ1ZmZlciB8PSAoKHRpbWUgJiAweDdGKSB8IDB4ODApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IDspIHtcbiAgICAgICAgICAgIHdyaXRldmFsID0gKGJ1ZmZlciAmIDB4RkYpO1xuXG4gICAgICAgICAgICB3cml0ZURhdGEoW3dyaXRldmFsXSk7XG5cbiAgICAgICAgICAgIHRyYWNrc2l6ZSArPSAxO1xuXG4gICAgICAgICAgICBpZiAoKGJ1ZmZlciAmIDB4ODApICE9IDApIHsgYnVmZmVyID4+PSA4OyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlZHRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdyaXRlIHRoZSBlbmQgb2YgdHJhY2sgbWFya2VyXG4gICAgZnVuY3Rpb24gd3JpdGVFbmRUcmFjaygpIHtcbiAgICAgICAgY29uc3QgZW5kdHJhY2sgPSBbMHhGRiwgMHgyRiwgMHgwMF07XG5cbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIHdyaXRlRGF0YShlbmR0cmFjayk7XG5cbiAgICAgICAgdHJhY2tzaXplICs9IDM7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgYSBrZXkgcHJlc3MgZXZlbnRcbiAgICBmdW5jdGlvbiB3cml0ZVByZXNzS2V5KGNoYW5uZWwsIGtleSwgdmVsb2NpdHkpIHtcbiAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIC8vIFdyaXRlIHByZXNzZWQga2V5IGFuZCBjaGFubmVsXG4gICAgICAgIGxldCB3b3JraW5nID0gbWlkaV9wcmVzc2tleSB8IGNoYW5uZWw7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIC8vIFdyaXRlIGtleVxuICAgICAgICB3b3JraW5nID0ga2V5ICYgMHg3RjtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgLy8gV2l0ZSB2ZWxvY2l0eVxuICAgICAgICB3b3JraW5nID0gdmVsb2NpdHkgJiAweDdGO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIGtleSByZWxlYXNlIGV2ZW50XG4gICAgZnVuY3Rpb24gd3JpdGVSZWxlYXNlS2V5KGNoYW5uZWwsIGtleSkge1xuICAgICAgICAvLyBXcml0ZSBxdWV1ZWQgdGltZVxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgLy8gV3JpdGUgcmVsZWFzZWQga2V5XG4gICAgICAgIGxldCB3b3JraW5nID0gbWlkaV9yZWxlYXNla2V5IHwgY2hhbm5lbDtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgLy8gV3JpdGUga2V5XG4gICAgICAgIHdvcmtpbmcgPSBrZXkgJiAweDdGO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAvLyBEdW1teVxuICAgICAgICB3b3JraW5nID0gMDtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgdHJhY2tzaXplICs9IDM7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgYSBwaXRjaCB3aGVlbC9iZW5kIGV2ZW50XG4gICAgZnVuY3Rpb24gd3JpdGVQaXRjaFdoZWVsKGNoYW5uZWwsIHdoZWVsKSB7XG4gICAgICAgIC8vIFdyaXRlIHF1ZXVlZCB0aW1lXG4gICAgICAgIHdyaXRlVGltZShxdWV1ZWR0aW1lKTtcblxuICAgICAgICBsZXQgd29ya2luZyA9IG1pZGlfcGl0Y2h3aGVlbCB8IGNoYW5uZWw7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHdvcmtpbmcgPSB3aGVlbCAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHdvcmtpbmcgPSAod2hlZWwgPj4gNykgJiAweDdGO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIHBhdGNoIGNoYW5nZSBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlQ2hhbmdlUGF0Y2goY2hhbm5lbCwgcGF0Y2gpIHtcbiAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIGxldCB3b3JraW5nID0gbWlkaV9jaGFuZ2VwYXRjaCB8IGNoYW5uZWw7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHdvcmtpbmcgPSBwYXRjaCAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHRyYWNrc2l6ZSArPSAyO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIGEgdmFsdWVkIGNvbnRyb2xsZXIgY2hhbmdlIGV2ZW50XG4gICAgZnVuY3Rpb24gd3JpdGVDaGFuZ2VDb250cm9sbGVyX1ZhbHVlZChjaGFubmVsLCBjb250cm9sLCB2YWx1ZSkge1xuICAgICAgICAvLyBXcml0ZSBxdWV1ZWQgdGltZVxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgbGV0IHdvcmtpbmcgPSBtaWRpX2NoYW5nZWNvbnRyb2xsZXIgfCBjaGFubmVsO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB3b3JraW5nID0gY29udHJvbCAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIC8vIFF1aXJrIGluIHZhbmlsbGEgRE9PTT8gTVVTIGNvbnRyb2xsZXIgdmFsdWVzIHNob3VsZCBiZSA3LWJpdCwgbm90IDgtYml0LlxuICAgICAgICB3b3JraW5nID0gdmFsdWUgJiAweDgwID8gMHg3RiA6IHZhbHVlO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIHZhbHVlbGVzcyBjb250cm9sbGVyIGNoYW5nZSBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlQ2hhbmdlQ29udHJvbGxlcl9WYWx1ZWxlc3MoY2hhbm5lbCwgY29udHJvbCkge1xuICAgICAgICB3cml0ZUNoYW5nZUNvbnRyb2xsZXJfVmFsdWVkKGNoYW5uZWwsIGNvbnRyb2wsIDApO1xuICAgIH1cblxuICAgIC8vIEFsbG9jYXRlIGEgZnJlZSBNSURJIGNoYW5uZWwuXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVNSURJQ2hhbm5lbCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IG1heDtcbiAgICAgICAgbGV0IGk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgY3VycmVudCBoaWdoZXN0LWFsbG9jYXRlZCBjaGFubmVsLlxuXG4gICAgICAgIG1heCA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBOVU1fQ0hBTk5FTFM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNoYW5uZWxfbWFwW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gY2hhbm5lbF9tYXBbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXggaXMgbm93IGVxdWFsIHRvIHRoZSBoaWdoZXN0LWFsbG9jYXRlZCBNSURJIGNoYW5uZWwuICBXZSBjYW5cbiAgICAgICAgLy8gbm93IGFsbG9jYXRlIHRoZSBuZXh0IGF2YWlsYWJsZSBjaGFubmVsLiAgVGhpcyBhbHNvIHdvcmtzIGlmXG4gICAgICAgIC8vIG5vIGNoYW5uZWxzIGFyZSBjdXJyZW50bHkgYWxsb2NhdGVkIChtYXg9LTEpXG5cbiAgICAgICAgcmVzdWx0ID0gbWF4ICsgMTtcblxuICAgICAgICAvLyBEb24ndCBhbGxvY2F0ZSB0aGUgTUlESSBwZXJjdXNzaW9uIGNoYW5uZWwhXG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTUlESV9QRVJDVVNTSU9OX0NIQU4pIHtcbiAgICAgICAgICAgICsrcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBHaXZlbiBhIE1VUyBjaGFubmVsIG51bWJlciwgZ2V0IHRoZSBNSURJIGNoYW5uZWwgbnVtYmVyIHRvIHVzZSBpbiB0aGUgb3V0cHV0dGVkIGZpbGUuXG4gICAgZnVuY3Rpb24gZ2V0TUlESUNoYW5uZWwobXVzX2NoYW5uZWwpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgTUlESSBjaGFubmVsIHRvIHVzZSBmb3IgdGhpcyBNVVMgY2hhbm5lbC5cbiAgICAgICAgLy8gTVVTIGNoYW5uZWwgMTUgaXMgdGhlIHBlcmN1c3NzaW9uIGNoYW5uZWwuXG5cbiAgICAgICAgaWYgKG11c19jaGFubmVsID09PSBNVVNfUEVSQ1VTU0lPTl9DSEFOKSB7XG4gICAgICAgICAgICByZXR1cm4gTUlESV9QRVJDVVNTSU9OX0NIQU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIE1JREkgY2hhbm5lbCBoYXNuJ3QgYmVlbiBhbGxvY2F0ZWQgZm9yIHRoaXMgTVVTIGNoYW5uZWxcbiAgICAgICAgLy8geWV0LCBhbGxvY2F0ZSB0aGUgbmV4dCBmcmVlIE1JREkgY2hhbm5lbC5cblxuICAgICAgICBpZiAoY2hhbm5lbF9tYXBbbXVzX2NoYW5uZWxdID09PSAtMSkge1xuICAgICAgICAgICAgY2hhbm5lbF9tYXBbbXVzX2NoYW5uZWxdID0gYWxsb2NhdGVNSURJQ2hhbm5lbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5uZWxfbWFwW211c19jaGFubmVsXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkTXVzSGVhZGVyKGRhdGFWaWV3KSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5jcmVhdGUobXVzaGVhZGVyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LmlkLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zY29yZWxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNig0LCB0cnVlKTtcbiAgICAgICAgb3V0cHV0LnNjb3Jlc3RhcnQgPSBkYXRhVmlldy5nZXRVaW50MTYoNiwgdHJ1ZSk7XG4gICAgICAgIG91dHB1dC5wcmltYXJ5Y2hhbm5lbHMgPSBkYXRhVmlldy5nZXRVaW50MTYoOCwgdHJ1ZSk7XG4gICAgICAgIG91dHB1dC5zZWNvbmRhcnljaGFubmVscyA9IGRhdGFWaWV3LmdldFVpbnQxNigxMCwgdHJ1ZSk7XG4gICAgICAgIG91dHB1dC5pbnN0cnVtZW50Y291bnQgPSBkYXRhVmlldy5nZXRVaW50MTYoMTIsIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydE11c1RvTWlkaShtdXNpbnB1dCkge1xuICAgICAgICAvLyBtYXN0ZXIgZGF0YXZpZXcgZm9yIGlucHV0IG11c1xuICAgICAgICBtdXNEYXRhVmlldyA9IG11c2lucHV0O1xuICAgICAgICBtdXNEYXRhUG9zaXRpb24gPSAwO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldE11c0J5dGU4KCkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gbXVzRGF0YVZpZXcuZ2V0VWludDgobXVzRGF0YVBvc2l0aW9uKTtcbiAgICAgICAgICAgIG11c0RhdGFQb3NpdGlvbiArPSAxO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cob3V0cHV0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXN0ZXIgZGF0YSBmb3Igb3V0cHV0IG1pZGlcbiAgICAgICAgY29uc3Qgb3V0cHV0QXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIG91dHB1dERhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG91dHB1dEFycmF5QnVmZmVyKTtcblxuICAgICAgICAvLyBEZXNjcmlwdG9yIGZvciB0aGUgY3VycmVudCBNVVMgZXZlbnRcbiAgICAgICAgbGV0IGV2ZW50ZGVzY3JpcHRvcjtcbiAgICAgICAgbGV0IGNoYW5uZWw7IC8vIENoYW5uZWwgbnVtYmVyXG4gICAgICAgIGxldCBtdXNfZXZlbnQ7XG5cblxuICAgICAgICAvLyBCdW5jaCBvZiB2YXJzIHJlYWQgZnJvbSBNVVMgbHVtcFxuICAgICAgICBsZXQga2V5O1xuICAgICAgICBsZXQgY29udHJvbGxlcm51bWJlcjtcbiAgICAgICAgbGV0IGNvbnRyb2xsZXJ2YWx1ZTtcblxuICAgICAgICAvLyBGbGFnIGZvciB3aGVuIHRoZSBzY29yZSBlbmQgbWFya2VyIGlzIGhpdC5cbiAgICAgICAgbGV0IGhpdHNjb3JlZW5kID0gMDtcblxuICAgICAgICAvLyBUZW1wIHdvcmtpbmcgYnl0ZVxuICAgICAgICBsZXQgd29ya2luZztcbiAgICAgICAgLy8gVXNlZCBpbiBidWlsZGluZyB1cCB0aW1lIGRlbGF5c1xuICAgICAgICBsZXQgdGltZWRlbGF5O1xuXG4gICAgICAgIC8vIEluaXRpYWxpc2UgY2hhbm5lbCBtYXAgdG8gbWFyayBhbGwgY2hhbm5lbHMgYXMgdW51c2VkLlxuICAgICAgICBmb3IgKGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgTlVNX0NIQU5ORUxTOyArK2NoYW5uZWwpIHtcbiAgICAgICAgICAgIGNoYW5uZWxfbWFwW2NoYW5uZWxdID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHcmFiIHRoZSBoZWFkZXJcbiAgICAgICAgY29uc3QgbXVzZmlsZWhlYWRlciA9IHJlYWRNdXNIZWFkZXIobXVzRGF0YVZpZXcpO1xuICAgICAgICAvLyBDaGVjayBNVVMgaGVhZGVyXG4gICAgICAgIGlmIChtdXNmaWxlaGVhZGVyLmlkWzBdICE9PSAnTScuY2hhckNvZGVBdCgwKSB8fCBtdXNmaWxlaGVhZGVyLmlkWzFdICE9PSAnVScuY2hhckNvZGVBdCgwKVxuICAgICAgICAgICAgfHwgbXVzZmlsZWhlYWRlci5pZFsyXSAhPT0gJ1MnLmNoYXJDb2RlQXQoMCkgfHwgbXVzZmlsZWhlYWRlci5pZFszXSAhPT0gMHgxQSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBNVVMgaGVhZGVyLicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlayB0byB3aGVyZSB0aGUgZGF0YSBpcyBoZWxkXG4gICAgICAgIG11c0RhdGFQb3NpdGlvbiA9IG11c2ZpbGVoZWFkZXIuc2NvcmVzdGFydDtcbiAgICAgICAgLy8gU28sIHdlIGNhbiBhc3N1bWUgdGhlIE1VUyBmaWxlIGlzIGZhaW50bHkgbGVnaXQuIExldCdzIHN0YXJ0IHdyaXRpbmcgTUlESSBkYXRhLi4uXG5cbiAgICAgICAgd3JpdGVNaWRpSGVhZGVyKCk7XG4gICAgICAgIHRyYWNrc2l6ZSA9IDA7XG5cbiAgICAgICAgLy8gTm93LCBwcm9jZXNzIHRoZSBNVVMgZmlsZTpcbiAgICAgICAgd2hpbGUgKGhpdHNjb3JlZW5kID09PSAwKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYSBibG9jayBvZiBldmVudHM6XG5cbiAgICAgICAgICAgIHdoaWxlIChoaXRzY29yZWVuZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIGNoYW5uZWwgbnVtYmVyIGFuZCBldmVudCBjb2RlOlxuICAgICAgICAgICAgICAgIGV2ZW50ZGVzY3JpcHRvciA9IGdldE11c0J5dGU4KCk7XG5cblxuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBnZXRNSURJQ2hhbm5lbChldmVudGRlc2NyaXB0b3IgJiAweDBGKTtcbiAgICAgICAgICAgICAgICBtdXNfZXZlbnQgPSBldmVudGRlc2NyaXB0b3IgJiAweDcwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobXVzX2V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgbXVzX3JlbGVhc2VrZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbXVzX3JlbGVhc2VrZXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdldE11c0J5dGU4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlUmVsZWFzZUtleShjaGFubmVsLCBrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIG11c19wcmVzc2tleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdldE11c0J5dGU4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHZlbG9jaXRpZXNbY2hhbm5lbF0gPSBnZXRNdXNCeXRlOCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHZlbG9jaXRpZXNbY2hhbm5lbF0gJj0gMHg3RjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXNfcHJlc3NrZXk6ICcra2V5KyAnICcgKyBjaGFubmVsdmVsb2NpdGllc1tjaGFubmVsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXNfcHJlc3NrZXk6ICcra2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVQcmVzc0tleShjaGFubmVsLCBrZXksIGNoYW5uZWx2ZWxvY2l0aWVzW2NoYW5uZWxdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBtdXNfcGl0Y2h3aGVlbDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXNfcGl0Y2h3aGVlbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVQaXRjaFdoZWVsKGNoYW5uZWwsIGtleSAqIDY0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBtdXNfc3lzdGVtZXZlbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbXVzX3N5c3RlbWV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVybnVtYmVyID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXJudW1iZXIgPCAxMCB8fCBjb250cm9sbGVybnVtYmVyID4gMTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb250cm9sbGVyIG51bWJlciBpbmFjY3VyYXRlIDEwLTE0OiAke2NvbnRyb2xsZXJudW1iZXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUNoYW5nZUNvbnRyb2xsZXJfVmFsdWVsZXNzKGNoYW5uZWwsIGNvbnRyb2xsZXJfbWFwW2NvbnRyb2xsZXJudW1iZXJdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBtdXNfY2hhbmdlY29udHJvbGxlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJudW1iZXIgPSBnZXRNdXNCeXRlOCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcnZhbHVlID0gZ2V0TXVzQnl0ZTgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXNfY2hhbmdlY29udHJvbGxlcjogJyArY29udHJvbGxlcm51bWJlcisnICcrY29udHJvbGxlcnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVybnVtYmVyID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUNoYW5nZVBhdGNoKGNoYW5uZWwsIGNvbnRyb2xsZXJ2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVybnVtYmVyIDwgMSB8fCBjb250cm9sbGVybnVtYmVyID4gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb250cm9sbGVyIG51bWJlciBpbmFjY3VyYXRlOiAke2NvbnRyb2xsZXJudW1iZXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUNoYW5nZUNvbnRyb2xsZXJfVmFsdWVkKGNoYW5uZWwsIGNvbnRyb2xsZXJfbWFwW2NvbnRyb2xsZXJudW1iZXJdLCBjb250cm9sbGVydmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIG11c19zY29yZWVuZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXNfc2NvcmVlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdHNjb3JlZW5kID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZXZlbnRkZXNjcmlwdG9yIGRlZmF1bHQ6ICcrZXZlbnRkZXNjcmlwdG9yICsgJyAnICsgKGV2ZW50ZGVzY3JpcHRvciAmIDB4ODApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChldmVudGRlc2NyaXB0b3IgJiAweDgwKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWxheSBjb3VudCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byByZWFkIHRoZSB0aW1lIGNvZGU6XG4gICAgICAgICAgICBpZiAoaGl0c2NvcmVlbmQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVhZCB0aW1lIGNvZGUnKTtcbiAgICAgICAgICAgICAgICB0aW1lZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgIC8vIGRlbGF5Q291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGdldE11c0J5dGU4KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGF5Q291bnRlciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aW1lZGVsYXkgPSB0aW1lZGVsYXkgKiAxMjggKyAod29ya2luZyAmIDB4N0YpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHdvcmtpbmcgJiAweDgwKSA9PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWxheSBjb3VudDogJytkZWxheUNvdW50ZXIgKyAnIHRpbWUgZGVsYXk6ICcgKyB0aW1lZGVsYXkpXG4gICAgICAgICAgICAgICAgcXVldWVkdGltZSArPSB0aW1lZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYENvbnZlcnRlZCAnJHtsdW1wSWR9JyBmcm9tIE1VUyB0byBNSURJIChXQUQ6ICcke3dhZElkfScpLmApO1xuICAgICAgICAvLyBFbmQgb2YgdHJhY2tcbiAgICAgICAgd3JpdGVFbmRUcmFjaygpO1xuXG4gICAgICAgIGNvbmZpcm1Xcml0ZSgpO1xuXG4gICAgICAgIC8vIFdyaXRlIHRoZSB0cmFjayBzaXplIGludG8gdGhlIHN0cmVhbVxuICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChNSURJX1RSQUNLTEVOR1RIX09GUyArIDAsICh0cmFja3NpemUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KE1JRElfVFJBQ0tMRU5HVEhfT0ZTICsgMSwgKHRyYWNrc2l6ZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgb3V0cHV0RGF0YVZpZXcuc2V0VWludDgoTUlESV9UUkFDS0xFTkdUSF9PRlMgKyAyLCAodHJhY2tzaXplID4+IDgpICYgMHhmZik7XG4gICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KE1JRElfVFJBQ0tMRU5HVEhfT0ZTICsgMywgdHJhY2tzaXplICYgMHhmZik7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dERhdGFWaWV3LmJ1ZmZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXN0ZXJPdXRwdXQgPSBjb252ZXJ0TXVzVG9NaWRpKGRhdGEpO1xuICAgIGlmIChtYXN0ZXJPdXRwdXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjb252ZXJ0ICcke2x1bXBJZH0nIGZyb20gTVVTIHRvIE1JREkgIChXQUQ6ICcke3dhZElkfScpLmAsIHsgbXVzRGF0YVBvc2l0aW9uIH0pO1xuICAgIH1cblxuICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgc3RhdHVzOiAnZG9uZScsXG4gICAgICAgIHdhZElkLFxuICAgICAgICBsdW1wSWQsXG4gICAgICAgIG1pZGk6IG1hc3Rlck91dHB1dCxcbiAgICB9KTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);