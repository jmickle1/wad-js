!function(I){var g={};function C(A){if(g[A])return g[A].exports;var n=g[A]={i:A,l:!1,exports:{}};return I[A].call(n.exports,n,n.exports,C),n.l=!0,n.exports}C.m=I,C.c=g,C.d=function(I,g,A){C.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:A})},C.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},C.t=function(I,g){if(1&g&&(I=C(I)),8&g)return I;if(4&g&&"object"==typeof I&&I&&I.__esModule)return I;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:I}),2&g&&"string"!=typeof I)for(var n in I)C.d(A,n,function(g){return I[g]}.bind(null,n));return A},C.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return C.d(g,"a",g),g},C.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},C.p="",C(C.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./app/lib/constants.js\nvar TEXT = 'text';\nvar MAPDATA = 'mapdata';\nvar MUSIC = 'music';\nvar MIDI = 'midi';\nvar MP3 = 'mp3';\nvar PNG = 'png';\nvar MUS = 'mus';\nvar GRAPHIC = 'graphic';\nvar FLAT = 'flat';\nvar MARKER = 'marker';\nvar ENDOOM = 'ENDOOM';\nvar TEXTUREx = ['TEXTURE1', 'TEXTURE2'];\nvar TEXTLUMPS = ['DEHACKED', 'MAPINFO', 'ZMAPINFO', 'EMAPINFO', 'DMXGUS', 'DMXGUSC', 'WADINFO', 'EMENUS', 'MUSINFO', 'SNDINFO', 'GLDEFS', 'KEYCONF', 'SCRIPTS', 'LANGUAGE', 'DECORATE', 'SBARINFO', 'MENUDEF'];\nvar DATA_LUMPS = ['PLAYPAL', 'COLORMAP', 'TEXTURE1', 'TEXTURE2', 'PNAMES', 'ENDOOM'];\nvar DEFAULT_EXTENSION = 'lmp';\nvar EXTENSIONS = {\n  text: 'txt',\n  mp3: 'mp3',\n  mus: 'mus',\n  midi: 'mid',\n  png: 'png'\n};\n/* MIDI player */\n\nvar MAX_I16 = Math.pow(2, 15);\nvar MIDI_AUDIO_BUFFER_SIZE = 8192; // signed 16-bit samples\n\nvar MIDI_AUDIO_S16LSB = 0x8010;\nvar MIDI_PATCH_URL = '/public/midi/pat/';\nvar MIDI_ERROR = 'MIDI_ERROR';\nvar MIDI_STATUS = 'MIDI_STATUS';\nvar MIDI_PRELOAD = 'MIDI_PRELOAD';\nvar MIDI_LOAD_FILE = 'MIDI_LOAD_FILE';\nvar MIDI_LOAD_PATCH = 'MIDI_LOAD_PATCH';\nvar MIDI_PLAY = 'MIDI_PLAY';\nvar MIDI_PAUSE = 'MIDI_PAUSE';\nvar MIDI_RESUME = 'MIDI_RESUME';\nvar MIDI_STOP = 'MIDI_STOP';\nvar MIDI_END = 'MIDI_END';\n/* File formats */\n\nvar SUPPORTED_FORMATS = ['.wad', '.zip', '.pk3', '.json'];\nvar VALID_FILE_FORMATS = ['', 'application/x-doom', 'application/zip', 'application/json'];\n/* WAD types */\n\nvar IWAD = 'IWAD';\nvar PWAD = 'PWAD';\nvar VALID_WAD_TYPES = [IWAD, PWAD];\n/* Lump types */\n\nvar MAP = 'maps';\nvar INTERMISSION = 'intermission';\nvar STATUS_BAR = 'status bar';\nvar MENU = 'menu';\nvar IMAGE_LUMPS = ['patches', 'flats', 'sprites', MENU, INTERMISSION, STATUS_BAR];\nvar UNCATEGORIZED = 'uncategorized';\n/* Lump names */\n\nvar THINGS = 'THINGS';\nvar TEXTMAP = 'TEXTMAP';\nvar ENDMAP = 'ENDMAP';\nvar MAP_LUMPS = [THINGS, 'LINEDEFS', 'SIDEDEFS', 'VERTEXES', 'SEGS', 'TEXTMAP', 'SSECTORS', 'NODES', 'SECTORS', 'REJECT', 'BLOCKMAP', // Hexen only\n'BEHAVIOR', // ZDoom only? (optional)\n'SCRIPTS', // Universal Doom Map Format only\n'ZNODES', 'DIALOGUE'];\nvar OPENGL_MAP_LUMPS = ['GL_VERT', 'GL_SEGS', 'GL_SSECT', 'GL_NODES', 'GL_PVS'];\nvar INTERMISSION_LUMPS = new RegExp(/WI[0-9a-zA-Z_]{1,}$/);\nvar STATUS_BAR_LUMPS = new RegExp(/(ST|AMM|BRDR_)[0-9a-zA-Z_]{1,}$/);\n/* Unique lumps */\n\nvar MAPINFO = ['MAPINFO', 'ZMAPINFO'];\nvar PLAYPAL = 'PLAYPAL';\nvar COLORMAP = 'COLORMAP';\nvar PNAMES = 'PNAMES';\nvar SBARINFO = 'SBARINFO';\nvar MENU_SCREENS = ['TITLEPIC', 'HELP', 'HELP1', 'HELP2', 'CREDIT'];\nvar INTERMISSION_SCREEN = 'INTERPIC';\nvar MUSIC_LUMPS = ['GENMIDI', 'DMXGUS', 'DMXGUSC', // Hexen only\n'SNDINFO'];\nvar DEMO_LUMPS = ['DEMO1', 'DEMO2', 'DEMO3', 'DEMO4'];\nvar LUMP_INDEX_ENTRY_SIZE = 16;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_SIZE = 4;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_NAME = 8;\nvar COLOR_COUNT_PER_PALETTE = 256;\nvar PALETTE_SIZE = 768;\nvar COLORMAP_SIZE = 256;\nvar BYTES_PER_COLOR = 3;\nvar GREEN_COLOR_OFFSET = 1;\nvar BLUE_COLOR_OFFSET = 2;\nvar FLAT_DIMENSIONS = 64;\nvar IMAGE_DATA_HEADER_SIZE = 8;\nvar IMAGE_DATA_BOUNDARY = 255;\nvar TRANSPARENT_PIXEL = -1;\n/* MUS -> MIDI conversion */\n\nvar MUS_HEADER = 'MUS';\nvar MIDI_HEADER = 'MThd';\nvar MIDI_HEADER_SIZE = 4;\nvar MIDI_HEADER_DATA = ['M'.charCodeAt(0), 'T'.charCodeAt(0), 'h'.charCodeAt(0), 'd'.charCodeAt(0), // Main header\n0x00, 0x00, 0x00, 0x06, // Header size\n0x00, 0x00, // MIDI type (0)\n0x00, 0x01, // Number of tracks\n0x00, 0x46, // Resolution\n'M'.charCodeAt(0), 'T'.charCodeAt(0), 'r'.charCodeAt(0), 'k'.charCodeAt(0), // Start of track\n0x00, 0x00, 0x00, 0x00];\nvar MUS_NUM_CHANNELS = 16;\nvar MUS_PERCUSSION_CHANNEL = 15;\nvar MIDI_PERCUSSION_CHANNEL = 9;\nvar MIDI_TRACKLENGTH_OFS = 18;\nvar MIDI_CONTROLLER_MAP = [0x00, 0x20, 0x01, 0x07, 0x0A, 0x0B, 0x5B, 0x5D, 0x40, 0x43, 0x78, 0x7B, 0x7E, 0x7F, 0x79]; // MUS event codes\n\nvar MUS_RELEASE_KEY = 0x00;\nvar MUS_PRESS_KEY = 0x10;\nvar MUS_PITCH_WHEEL = 0x20;\nvar MUS_SYSTEM_EVENT = 0x30;\nvar MUS_CHANGE_CONTROLLER = 0x40;\nvar MUS_SCORE_END = 0x60; // MIDI event codes\n\nvar MIDI_RELEASE_KEY = 0x80;\nvar MIDI_PRESS_KEY = 0x90;\nvar MIDI_CHANGE_CONTROLLER = 0xB0;\nvar MIDI_CHANGE_PATCH = 0xC0;\nvar MIDI_PITCH_WHEEL = 0xE0;\n// CONCATENATED MODULE: ./app/workers/midiConverter.js\n\n\n// TODO: Send the error string in postMessage\n\nonmessage = (message) => {\n    const { wadId, lumpId, data } = message.data;\n\n    console.log(`Converting '${lumpId}' from MUS to MIDI (WAD: '${wadId}') ...`);\n\n    // Structure to hold MUS file header\n    const musheader = {\n        id: [],\n        scorelength: null,\n        scorestart: null,\n        primarychannels: null,\n        secondarychannels: null,\n        instrumentcount: null,\n    };\n\n    let musDataView;\n    let musDataPosition;\n\n    // Cached channel velocities\n    const channelvelocities = [\n        127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,\n    ];\n\n    // Timestamps between sequences of MUS events\n    let queuedtime = 0;\n\n    // Counter for the length of the track\n    let tracksize;\n\n    const channelMap = [];\n\n    // Main DataView for writing to. This is used by writeData();\n    let outputDataView;\n\n    // Wrapper function to work like slade's memchunk.write()\n    // I'm so lazy\n    let position = 0;\n    let dataToWrite = [];\n    function writeData(bytes) {\n        dataToWrite = dataToWrite.concat(bytes);\n    }\n\n    function confirmWrite() {\n        const newBuffer = new ArrayBuffer(dataToWrite.length);\n        outputDataView = new DataView(newBuffer);\n        // Then write the data\n        for (let i = 0; i < dataToWrite.length; i++) {\n            outputDataView.setUint8(position, dataToWrite[i]);\n            position += 1;\n        }\n    }\n\n    // Write timestamp to a MIDI file.\n    function writeTime(time) {\n        let buffer = time & 0x7F;\n        let writeval;\n\n        while ((time >>= 7) != 0) {\n            buffer <<= 8;\n            buffer |= ((time & 0x7F) | 0x80);\n        }\n\n        for (; ;) {\n            writeval = (buffer & 0xFF);\n\n            writeData([writeval]);\n\n            tracksize += 1;\n\n            if ((buffer & 0x80) != 0) { buffer >>= 8; } else {\n                queuedtime = 0;\n                return;\n            }\n        }\n    }\n\n    // Write the end of track marker\n    function writeEndTrack() {\n        const endtrack = [0xFF, 0x2F, 0x00];\n\n        writeTime(queuedtime);\n\n        writeData(endtrack);\n\n        tracksize += 3;\n    }\n\n    // Write a key press event\n    function writePressKey(channel, key, velocity) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        // Write pressed key and channel\n        let working = MIDI_PRESS_KEY | channel;\n        writeData([working]);\n\n        // Write key\n        working = key & 0x7F;\n        writeData([working]);\n\n        // Wite velocity\n        working = velocity & 0x7F;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a key release event\n    function writeReleaseKey(channel, key) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        // Write released key\n        let working = MIDI_RELEASE_KEY | channel;\n        writeData([working]);\n\n        // Write key\n        working = key & 0x7F;\n        writeData([working]);\n\n        // Dummy\n        working = 0;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a pitch wheel/bend event\n    function writePitchWheel(channel, wheel) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = MIDI_PITCH_WHEEL | channel;\n        writeData([working]);\n\n        working = wheel & 0x7F;\n        writeData([working]);\n\n        working = (wheel >> 7) & 0x7F;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a patch change event\n    function writeChangePatch(channel, patch) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = MIDI_CHANGE_PATCH | channel;\n        writeData([working]);\n\n        working = patch & 0x7F;\n        writeData([working]);\n\n        tracksize += 2;\n    }\n\n    // Write a valued controller change event\n    function writeChangeControllerValued(channel, control, value) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = MIDI_CHANGE_CONTROLLER | channel;\n        writeData([working]);\n\n        working = control & 0x7F;\n        writeData([working]);\n\n        // Quirk in vanilla DOOM? MUS controller values should be 7-bit, not 8-bit.\n        working = value & 0x80 ? 0x7F : value;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a valueless controller change event\n    function writeChangeControllerValueless(channel, control) {\n        writeChangeControllerValued(channel, control, 0);\n    }\n\n    // Allocate a free MIDI channel.\n    function allocateMIDIChannel() {\n        let result;\n        let max;\n        let i;\n\n        // Find the current highest-allocated channel.\n\n        max = -1;\n\n        for (i = 0; i < MUS_NUM_CHANNELS; ++i) {\n            if (channelMap[i] > max) {\n                max = channelMap[i];\n            }\n        }\n\n        // max is now equal to the highest-allocated MIDI channel.  We can\n        // now allocate the next available channel.  This also works if\n        // no channels are currently allocated (max=-1)\n\n        result = max + 1;\n\n        // Don't allocate the MIDI percussion channel!\n\n        if (result === MIDI_PERCUSSION_CHANNEL) {\n            ++result;\n        }\n\n        return result;\n    }\n\n    // Given a MUS channel number, get the MIDI channel number to use in the outputted file.\n    function getMIDIChannel(musChannel) {\n        // Find the MIDI channel to use for this MUS channel.\n        // MUS channel 15 is the percusssion channel.\n\n        if (musChannel === MUS_PERCUSSION_CHANNEL) {\n            return MIDI_PERCUSSION_CHANNEL;\n        }\n\n        // If a MIDI channel hasn't been allocated for this MUS channel\n        // yet, allocate the next free MIDI channel.\n\n        if (channelMap[musChannel] === -1) {\n            channelMap[musChannel] = allocateMIDIChannel();\n        }\n\n        return channelMap[musChannel];\n    }\n\n    function readMusHeader(dataView) {\n        const output = Object.create(musheader);\n\n        for (let i = 0; i < 4; i++) {\n            output.id.push(dataView.getUint8(i));\n        }\n        output.scorelength = dataView.getUint16(4, true);\n        output.scorestart = dataView.getUint16(6, true);\n        output.primarychannels = dataView.getUint16(8, true);\n        output.secondarychannels = dataView.getUint16(10, true);\n        output.instrumentcount = dataView.getUint16(12, true);\n\n        return output;\n    }\n\n    function convertMusToMidi(musinput) {\n        // master dataview for input mus\n        musDataView = musinput;\n        musDataPosition = 0;\n\n        function getMusByte8() {\n            const output = musDataView.getUint8(musDataPosition);\n            musDataPosition += 1;\n            // console.log(output);\n            return output;\n        }\n\n        // master data for output midi\n        const outputArrayBuffer = new ArrayBuffer(0);\n        outputDataView = new DataView(outputArrayBuffer);\n\n        // Descriptor for the current MUS event\n        let eventdescriptor;\n        let channel; // Channel number\n        let musEvent;\n\n\n        // Bunch of vars read from MUS lump\n        let key;\n        let controllernumber;\n        let controllervalue;\n\n        // Flag for when the score end marker is hit.\n        let hitscoreend = 0;\n\n        // Temp working byte\n        let working;\n        // Used in building up time delays\n        let timedelay;\n\n        // Initialise channel map to mark all channels as unused.\n        for (channel = 0; channel < MUS_NUM_CHANNELS; ++channel) {\n            channelMap[channel] = -1;\n        }\n\n        // Grab the header\n        const musfileheader = readMusHeader(musDataView);\n        // Check MUS header\n        if (musfileheader.id[0] !== 'M'.charCodeAt(0) || musfileheader.id[1] !== 'U'.charCodeAt(0)\n            || musfileheader.id[2] !== 'S'.charCodeAt(0) || musfileheader.id[3] !== 0x1A) {\n            console.error('Invalid MUS header.');\n            return false;\n        }\n\n        // Seek to where the data is held\n        musDataPosition = musfileheader.scorestart;\n        // So, we can assume the MUS file is faintly legit. Let's start writing MIDI data...\n\n        writeData(MIDI_HEADER_DATA);\n        tracksize = 0;\n\n        // Now, process the MUS file:\n        while (hitscoreend === 0) {\n            // Handle a block of events:\n\n            while (hitscoreend === 0) {\n                // Fetch channel number and event code:\n                eventdescriptor = getMusByte8();\n\n\n                channel = getMIDIChannel(eventdescriptor & 0x0F);\n                musEvent = eventdescriptor & 0x70;\n                switch (musEvent) {\n                case MUS_RELEASE_KEY:\n                    // console.log('MUS_RELEASE_KEY');\n                    key = getMusByte8();\n\n                    writeReleaseKey(channel, key);\n\n                    break;\n\n                case MUS_PRESS_KEY:\n                    key = getMusByte8();\n\n                    if (key & 0x80) {\n                        channelvelocities[channel] = getMusByte8();\n\n                        channelvelocities[channel] &= 0x7F;\n\n                        // console.log('MUS_PRESS_KEY: '+key+ ' ' + channelvelocities[channel]);\n                    } else {\n                        // console.log('MUS_PRESS_KEY: '+key);\n                    }\n\n                    writePressKey(channel, key, channelvelocities[channel]);\n\n                    break;\n\n                case MUS_PITCH_WHEEL:\n                    // console.log('MUS_PITCH_WHEEL');\n                    key = getMusByte8();\n\n                    writePitchWheel(channel, key * 64);\n\n                    break;\n\n                case MUS_SYSTEM_EVENT:\n                    // console.log('MUS_SYSTEM_EVENT');\n                    controllernumber = getMusByte8();\n\n                    if (controllernumber < 10 || controllernumber > 14) {\n                        console.error(`Controller number inaccurate 10-14: ${controllernumber}`);\n                        return false;\n                    }\n\n                    writeChangeControllerValueless(channel, MIDI_CONTROLLER_MAP[controllernumber]);\n\n                    break;\n\n                case MUS_CHANGE_CONTROLLER:\n                    controllernumber = getMusByte8();\n                    controllervalue = getMusByte8();\n                    // console.log('MUS_CHANGE_CONTROLLER: ' +controllernumber+' '+controllervalue);\n                    if (controllernumber == 0) {\n                        writeChangePatch(channel, controllervalue);\n                    } else {\n                        if (controllernumber < 1 || controllernumber > 9) {\n                            console.error(`Controller number inaccurate: ${controllernumber}`);\n                            return false;\n                        }\n\n                        writeChangeControllerValued(channel, MIDI_CONTROLLER_MAP[controllernumber], controllervalue);\n                    }\n\n                    break;\n\n                case MUS_SCORE_END:\n                    // console.log('musScoreEnd');\n                    hitscoreend = 1;\n                    break;\n\n                default:\n                    // console.log('eventdescriptor default: '+eventdescriptor + ' ' + (eventdescriptor & 0x80));\n                    return false;\n                }\n                if ((eventdescriptor & 0x80) != 0) {\n                    // console.log('delay count');\n                    break;\n                }\n            }\n            // Now we need to read the time code:\n            if (hitscoreend === 0) {\n                // console.log('read time code');\n                timedelay = 0;\n                // delayCounter = 0;\n                for (; ;) {\n                    working = getMusByte8();\n                    // delayCounter += 1;\n                    timedelay = timedelay * 128 + (working & 0x7F);\n                    if ((working & 0x80) == 0) { break; }\n                }\n                // console.log('delay count: '+delayCounter + ' time delay: ' + timedelay)\n                queuedtime += timedelay;\n            }\n        }\n        console.log(`Converted '${lumpId}' from MUS to MIDI (WAD: '${wadId}').`);\n        // End of track\n        writeEndTrack();\n\n        confirmWrite();\n\n        // Write the track size into the stream\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 0, (tracksize >> 24) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 1, (tracksize >> 16) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 2, (tracksize >> 8) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 3, tracksize & 0xff);\n\n        return outputDataView.buffer;\n    }\n\n    const masterOutput = convertMusToMidi(data);\n    if (masterOutput === false) {\n        console.error(`Failed to convert '${lumpId}' from MUS to MIDI (WAD: '${wadId}').`, { musDataPosition });\n    }\n\n    postMessage({\n        wadId,\n        lumpId,\n        midi: masterOutput,\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC9saWIvY29uc3RhbnRzLmpzP2I2NGQiLCJ3ZWJwYWNrOi8vLy4vYXBwL3dvcmtlcnMvbWlkaUNvbnZlcnRlci5qcz8yOTllIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBURVhUID0gJ3RleHQnO1xuZXhwb3J0IGNvbnN0IE1BUERBVEEgPSAnbWFwZGF0YSc7XG5leHBvcnQgY29uc3QgTVVTSUMgPSAnbXVzaWMnO1xuZXhwb3J0IGNvbnN0IE1JREkgPSAnbWlkaSc7XG5leHBvcnQgY29uc3QgTVAzID0gJ21wMyc7XG5leHBvcnQgY29uc3QgUE5HID0gJ3BuZyc7XG5leHBvcnQgY29uc3QgTVVTID0gJ211cyc7XG5leHBvcnQgY29uc3QgR1JBUEhJQyA9ICdncmFwaGljJztcbmV4cG9ydCBjb25zdCBGTEFUID0gJ2ZsYXQnO1xuZXhwb3J0IGNvbnN0IE1BUktFUiA9ICdtYXJrZXInO1xuZXhwb3J0IGNvbnN0IEVORE9PTSA9ICdFTkRPT00nO1xuZXhwb3J0IGNvbnN0IFRFWFRVUkV4ID0gWydURVhUVVJFMScsICdURVhUVVJFMiddO1xuXG5leHBvcnQgY29uc3QgVEVYVExVTVBTID0gWydERUhBQ0tFRCcsICdNQVBJTkZPJywgJ1pNQVBJTkZPJywgJ0VNQVBJTkZPJyxcbiAgICAnRE1YR1VTJywgJ0RNWEdVU0MnLCAnV0FESU5GTycsICdFTUVOVVMnLCAnTVVTSU5GTycsXG4gICAgJ1NORElORk8nLCAnR0xERUZTJywgJ0tFWUNPTkYnLCAnU0NSSVBUUycsICdMQU5HVUFHRScsXG4gICAgJ0RFQ09SQVRFJywgJ1NCQVJJTkZPJywgJ01FTlVERUYnXTtcbmV4cG9ydCBjb25zdCBEQVRBX0xVTVBTID0gWydQTEFZUEFMJywgJ0NPTE9STUFQJywgJ1RFWFRVUkUxJywgJ1RFWFRVUkUyJywgJ1BOQU1FUycsXG4gICAgJ0VORE9PTSddO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9FWFRFTlNJT04gPSAnbG1wJztcbmV4cG9ydCBjb25zdCBFWFRFTlNJT05TID0ge1xuICAgIHRleHQ6ICd0eHQnLFxuICAgIG1wMzogJ21wMycsXG4gICAgbXVzOiAnbXVzJyxcbiAgICBtaWRpOiAnbWlkJyxcbiAgICBwbmc6ICdwbmcnLFxufTtcblxuLyogTUlESSBwbGF5ZXIgKi9cblxuZXhwb3J0IGNvbnN0IE1BWF9JMTYgPSAyICoqIDE1O1xuXG5leHBvcnQgY29uc3QgTUlESV9BVURJT19CVUZGRVJfU0laRSA9IDgxOTI7XG5cbi8vIHNpZ25lZCAxNi1iaXQgc2FtcGxlc1xuZXhwb3J0IGNvbnN0IE1JRElfQVVESU9fUzE2TFNCID0gMHg4MDEwO1xuXG5leHBvcnQgY29uc3QgTUlESV9QQVRDSF9VUkwgPSAnL3B1YmxpYy9taWRpL3BhdC8nO1xuXG5leHBvcnQgY29uc3QgTUlESV9FUlJPUiA9ICdNSURJX0VSUk9SJztcblxuZXhwb3J0IGNvbnN0IE1JRElfU1RBVFVTID0gJ01JRElfU1RBVFVTJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUFJFTE9BRCA9ICdNSURJX1BSRUxPQUQnO1xuXG5leHBvcnQgY29uc3QgTUlESV9MT0FEX0ZJTEUgPSAnTUlESV9MT0FEX0ZJTEUnO1xuXG5leHBvcnQgY29uc3QgTUlESV9MT0FEX1BBVENIID0gJ01JRElfTE9BRF9QQVRDSCc7XG5cbmV4cG9ydCBjb25zdCBNSURJX1BMQVkgPSAnTUlESV9QTEFZJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUEFVU0UgPSAnTUlESV9QQVVTRSc7XG5cbmV4cG9ydCBjb25zdCBNSURJX1JFU1VNRSA9ICdNSURJX1JFU1VNRSc7XG5cbmV4cG9ydCBjb25zdCBNSURJX1NUT1AgPSAnTUlESV9TVE9QJztcblxuZXhwb3J0IGNvbnN0IE1JRElfRU5EID0gJ01JRElfRU5EJztcblxuXG4vKiBGaWxlIGZvcm1hdHMgKi9cblxuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9GT1JNQVRTID0gW1xuICAgICcud2FkJyxcbiAgICAnLnppcCcsXG4gICAgJy5wazMnLFxuICAgICcuanNvbicsXG5dO1xuXG5leHBvcnQgY29uc3QgVkFMSURfRklMRV9GT1JNQVRTID0gW1xuICAgICcnLFxuICAgICdhcHBsaWNhdGlvbi94LWRvb20nLFxuICAgICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICdhcHBsaWNhdGlvbi9qc29uJyxcbl07XG5cbi8qIFdBRCB0eXBlcyAqL1xuXG5leHBvcnQgY29uc3QgSVdBRCA9ICdJV0FEJztcbmV4cG9ydCBjb25zdCBQV0FEID0gJ1BXQUQnO1xuZXhwb3J0IGNvbnN0IFZBTElEX1dBRF9UWVBFUyA9IFtJV0FELCBQV0FEXTtcblxuLyogTHVtcCB0eXBlcyAqL1xuXG5leHBvcnQgY29uc3QgTUFQID0gJ21hcHMnO1xuXG5leHBvcnQgY29uc3QgSU5URVJNSVNTSU9OID0gJ2ludGVybWlzc2lvbic7XG5cbmV4cG9ydCBjb25zdCBTVEFUVVNfQkFSID0gJ3N0YXR1cyBiYXInO1xuXG5leHBvcnQgY29uc3QgTUVOVSA9ICdtZW51JztcblxuZXhwb3J0IGNvbnN0IElNQUdFX0xVTVBTID0gW1xuICAgICdwYXRjaGVzJyxcbiAgICAnZmxhdHMnLFxuICAgICdzcHJpdGVzJyxcbiAgICBNRU5VLFxuICAgIElOVEVSTUlTU0lPTixcbiAgICBTVEFUVVNfQkFSLFxuXTtcblxuZXhwb3J0IGNvbnN0IFVOQ0FURUdPUklaRUQgPSAndW5jYXRlZ29yaXplZCc7XG5cbi8qIEx1bXAgbmFtZXMgKi9cblxuZXhwb3J0IGNvbnN0IFRISU5HUyA9ICdUSElOR1MnO1xuXG5leHBvcnQgY29uc3QgVEVYVE1BUCA9ICdURVhUTUFQJztcblxuZXhwb3J0IGNvbnN0IEVORE1BUCA9ICdFTkRNQVAnO1xuXG5leHBvcnQgY29uc3QgTUFQX0xVTVBTID0gW1xuICAgIFRISU5HUyxcbiAgICAnTElORURFRlMnLFxuICAgICdTSURFREVGUycsXG4gICAgJ1ZFUlRFWEVTJyxcbiAgICAnU0VHUycsXG4gICAgJ1RFWFRNQVAnLFxuICAgICdTU0VDVE9SUycsXG4gICAgJ05PREVTJyxcbiAgICAnU0VDVE9SUycsXG4gICAgJ1JFSkVDVCcsXG4gICAgJ0JMT0NLTUFQJyxcbiAgICAvLyBIZXhlbiBvbmx5XG4gICAgJ0JFSEFWSU9SJyxcbiAgICAvLyBaRG9vbSBvbmx5PyAob3B0aW9uYWwpXG4gICAgJ1NDUklQVFMnLFxuICAgIC8vIFVuaXZlcnNhbCBEb29tIE1hcCBGb3JtYXQgb25seVxuICAgICdaTk9ERVMnLFxuICAgICdESUFMT0dVRScsXG5dO1xuXG5leHBvcnQgY29uc3QgT1BFTkdMX01BUF9MVU1QUyA9IFtcbiAgICAnR0xfVkVSVCcsXG4gICAgJ0dMX1NFR1MnLFxuICAgICdHTF9TU0VDVCcsXG4gICAgJ0dMX05PREVTJyxcbiAgICAnR0xfUFZTJyxcbl07XG5cbmV4cG9ydCBjb25zdCBJTlRFUk1JU1NJT05fTFVNUFMgPSBuZXcgUmVnRXhwKC9XSVswLTlhLXpBLVpfXXsxLH0kLyk7XG5cbmV4cG9ydCBjb25zdCBTVEFUVVNfQkFSX0xVTVBTID0gbmV3IFJlZ0V4cCgvKFNUfEFNTXxCUkRSXylbMC05YS16QS1aX117MSx9JC8pO1xuXG4vKiBVbmlxdWUgbHVtcHMgKi9cblxuZXhwb3J0IGNvbnN0IE1BUElORk8gPSBbJ01BUElORk8nLCAnWk1BUElORk8nXTtcblxuZXhwb3J0IGNvbnN0IFBMQVlQQUwgPSAnUExBWVBBTCc7XG5leHBvcnQgY29uc3QgQ09MT1JNQVAgPSAnQ09MT1JNQVAnO1xuXG5leHBvcnQgY29uc3QgUE5BTUVTID0gJ1BOQU1FUyc7XG5cbmV4cG9ydCBjb25zdCBTQkFSSU5GTyA9ICdTQkFSSU5GTyc7XG5cbmV4cG9ydCBjb25zdCBNRU5VX1NDUkVFTlMgPSBbXG4gICAgJ1RJVExFUElDJyxcbiAgICAnSEVMUCcsXG4gICAgJ0hFTFAxJyxcbiAgICAnSEVMUDInLFxuICAgICdDUkVESVQnLFxuXTtcblxuZXhwb3J0IGNvbnN0IElOVEVSTUlTU0lPTl9TQ1JFRU4gPSAnSU5URVJQSUMnO1xuXG5leHBvcnQgY29uc3QgTVVTSUNfTFVNUFMgPSBbXG4gICAgJ0dFTk1JREknLFxuICAgICdETVhHVVMnLFxuICAgICdETVhHVVNDJyxcbiAgICAvLyBIZXhlbiBvbmx5XG4gICAgJ1NORElORk8nLFxuXTtcblxuZXhwb3J0IGNvbnN0IERFTU9fTFVNUFMgPSBbXG4gICAgJ0RFTU8xJyxcbiAgICAnREVNTzInLFxuICAgICdERU1PMycsXG4gICAgJ0RFTU80Jyxcbl07XG5cbmV4cG9ydCBjb25zdCBMVU1QX0lOREVYX0VOVFJZX1NJWkUgPSAxNjtcbmV4cG9ydCBjb25zdCBMVU1QX0lOREVYX0VOVFJZX09GRlNFVF9UT19MVU1QX1NJWkUgPSA0O1xuZXhwb3J0IGNvbnN0IExVTVBfSU5ERVhfRU5UUllfT0ZGU0VUX1RPX0xVTVBfTkFNRSA9IDg7XG5cbmV4cG9ydCBjb25zdCBDT0xPUl9DT1VOVF9QRVJfUEFMRVRURSA9IDI1NjtcbmV4cG9ydCBjb25zdCBQQUxFVFRFX1NJWkUgPSA3Njg7XG5leHBvcnQgY29uc3QgQ09MT1JNQVBfU0laRSA9IDI1NjtcblxuZXhwb3J0IGNvbnN0IEJZVEVTX1BFUl9DT0xPUiA9IDM7XG5leHBvcnQgY29uc3QgR1JFRU5fQ09MT1JfT0ZGU0VUID0gMTtcbmV4cG9ydCBjb25zdCBCTFVFX0NPTE9SX09GRlNFVCA9IDI7XG5cbmV4cG9ydCBjb25zdCBGTEFUX0RJTUVOU0lPTlMgPSA2NDtcblxuZXhwb3J0IGNvbnN0IElNQUdFX0RBVEFfSEVBREVSX1NJWkUgPSA4O1xuZXhwb3J0IGNvbnN0IElNQUdFX0RBVEFfQk9VTkRBUlkgPSAyNTU7XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BBUkVOVF9QSVhFTCA9IC0xO1xuXG4vKiBNVVMgLT4gTUlESSBjb252ZXJzaW9uICovXG5cbmV4cG9ydCBjb25zdCBNVVNfSEVBREVSID0gJ01VUyc7XG5leHBvcnQgY29uc3QgTUlESV9IRUFERVIgPSAnTVRoZCc7XG5leHBvcnQgY29uc3QgTUlESV9IRUFERVJfU0laRSA9IDQ7XG5leHBvcnQgY29uc3QgTUlESV9IRUFERVJfREFUQSA9IFtcbiAgICAnTScuY2hhckNvZGVBdCgwKSwgJ1QnLmNoYXJDb2RlQXQoMCksICdoJy5jaGFyQ29kZUF0KDApLCAnZCcuY2hhckNvZGVBdCgwKSwgLy8gTWFpbiBoZWFkZXJcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDA2LCAvLyBIZWFkZXIgc2l6ZVxuICAgIDB4MDAsIDB4MDAsIC8vIE1JREkgdHlwZSAoMClcbiAgICAweDAwLCAweDAxLCAvLyBOdW1iZXIgb2YgdHJhY2tzXG4gICAgMHgwMCwgMHg0NiwgLy8gUmVzb2x1dGlvblxuICAgICdNJy5jaGFyQ29kZUF0KDApLCAnVCcuY2hhckNvZGVBdCgwKSwgJ3InLmNoYXJDb2RlQXQoMCksICdrJy5jaGFyQ29kZUF0KDApLCAvLyBTdGFydCBvZiB0cmFja1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIFBsYWNlaG9sZGVyIGZvciB0cmFjayBsZW5ndGhcbl07XG5cbmV4cG9ydCBjb25zdCBNVVNfTlVNX0NIQU5ORUxTID0gMTY7XG5leHBvcnQgY29uc3QgTVVTX1BFUkNVU1NJT05fQ0hBTk5FTCA9IDE1O1xuZXhwb3J0IGNvbnN0IE1JRElfUEVSQ1VTU0lPTl9DSEFOTkVMID0gOTtcbmV4cG9ydCBjb25zdCBNSURJX1RSQUNLTEVOR1RIX09GUyA9IDE4O1xuXG5leHBvcnQgY29uc3QgTUlESV9DT05UUk9MTEVSX01BUCA9IFtcbiAgICAweDAwLCAweDIwLCAweDAxLCAweDA3LCAweDBBLCAweDBCLCAweDVCLCAweDVELCAweDQwLCAweDQzLCAweDc4LCAweDdCLCAweDdFLCAweDdGLCAweDc5LFxuXTtcblxuLy8gTVVTIGV2ZW50IGNvZGVzXG5leHBvcnQgY29uc3QgTVVTX1JFTEVBU0VfS0VZID0gMHgwMDtcbmV4cG9ydCBjb25zdCBNVVNfUFJFU1NfS0VZID0gMHgxMDtcbmV4cG9ydCBjb25zdCBNVVNfUElUQ0hfV0hFRUwgPSAweDIwO1xuZXhwb3J0IGNvbnN0IE1VU19TWVNURU1fRVZFTlQgPSAweDMwO1xuZXhwb3J0IGNvbnN0IE1VU19DSEFOR0VfQ09OVFJPTExFUiA9IDB4NDA7XG5leHBvcnQgY29uc3QgTVVTX1NDT1JFX0VORCA9IDB4NjA7XG5cbi8vIE1JREkgZXZlbnQgY29kZXNcbmV4cG9ydCBjb25zdCBNSURJX1JFTEVBU0VfS0VZID0gMHg4MDtcbmV4cG9ydCBjb25zdCBNSURJX1BSRVNTX0tFWSA9IDB4OTA7XG5leHBvcnQgY29uc3QgTUlESV9DSEFOR0VfQ09OVFJPTExFUiA9IDB4QjA7XG5leHBvcnQgY29uc3QgTUlESV9DSEFOR0VfUEFUQ0ggPSAweEMwO1xuZXhwb3J0IGNvbnN0IE1JRElfUElUQ0hfV0hFRUwgPSAweEUwO1xuIiwiaW1wb3J0IHtcbiAgICBNSURJX0hFQURFUl9EQVRBLFxuICAgIE1VU19OVU1fQ0hBTk5FTFMsXG4gICAgTVVTX1BFUkNVU1NJT05fQ0hBTk5FTCxcbiAgICBNSURJX1BFUkNVU1NJT05fQ0hBTk5FTCxcbiAgICBNSURJX1RSQUNLTEVOR1RIX09GUyxcbiAgICBNSURJX0NPTlRST0xMRVJfTUFQLFxuICAgIE1VU19SRUxFQVNFX0tFWSxcbiAgICBNVVNfUFJFU1NfS0VZLFxuICAgIE1VU19QSVRDSF9XSEVFTCxcbiAgICBNVVNfU1lTVEVNX0VWRU5ULFxuICAgIE1VU19DSEFOR0VfQ09OVFJPTExFUixcbiAgICBNVVNfU0NPUkVfRU5ELFxuICAgIE1JRElfUkVMRUFTRV9LRVksXG4gICAgTUlESV9QUkVTU19LRVksXG4gICAgTUlESV9DSEFOR0VfQ09OVFJPTExFUixcbiAgICBNSURJX0NIQU5HRV9QQVRDSCxcbiAgICBNSURJX1BJVENIX1dIRUVMLFxufSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcblxuLy8gVE9ETzogU2VuZCB0aGUgZXJyb3Igc3RyaW5nIGluIHBvc3RNZXNzYWdlXG5cbm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgeyB3YWRJZCwgbHVtcElkLCBkYXRhIH0gPSBtZXNzYWdlLmRhdGE7XG5cbiAgICBjb25zb2xlLmxvZyhgQ29udmVydGluZyAnJHtsdW1wSWR9JyBmcm9tIE1VUyB0byBNSURJIChXQUQ6ICcke3dhZElkfScpIC4uLmApO1xuXG4gICAgLy8gU3RydWN0dXJlIHRvIGhvbGQgTVVTIGZpbGUgaGVhZGVyXG4gICAgY29uc3QgbXVzaGVhZGVyID0ge1xuICAgICAgICBpZDogW10sXG4gICAgICAgIHNjb3JlbGVuZ3RoOiBudWxsLFxuICAgICAgICBzY29yZXN0YXJ0OiBudWxsLFxuICAgICAgICBwcmltYXJ5Y2hhbm5lbHM6IG51bGwsXG4gICAgICAgIHNlY29uZGFyeWNoYW5uZWxzOiBudWxsLFxuICAgICAgICBpbnN0cnVtZW50Y291bnQ6IG51bGwsXG4gICAgfTtcblxuICAgIGxldCBtdXNEYXRhVmlldztcbiAgICBsZXQgbXVzRGF0YVBvc2l0aW9uO1xuXG4gICAgLy8gQ2FjaGVkIGNoYW5uZWwgdmVsb2NpdGllc1xuICAgIGNvbnN0IGNoYW5uZWx2ZWxvY2l0aWVzID0gW1xuICAgICAgICAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsXG4gICAgXTtcblxuICAgIC8vIFRpbWVzdGFtcHMgYmV0d2VlbiBzZXF1ZW5jZXMgb2YgTVVTIGV2ZW50c1xuICAgIGxldCBxdWV1ZWR0aW1lID0gMDtcblxuICAgIC8vIENvdW50ZXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIHRyYWNrXG4gICAgbGV0IHRyYWNrc2l6ZTtcblxuICAgIGNvbnN0IGNoYW5uZWxNYXAgPSBbXTtcblxuICAgIC8vIE1haW4gRGF0YVZpZXcgZm9yIHdyaXRpbmcgdG8uIFRoaXMgaXMgdXNlZCBieSB3cml0ZURhdGEoKTtcbiAgICBsZXQgb3V0cHV0RGF0YVZpZXc7XG5cbiAgICAvLyBXcmFwcGVyIGZ1bmN0aW9uIHRvIHdvcmsgbGlrZSBzbGFkZSdzIG1lbWNodW5rLndyaXRlKClcbiAgICAvLyBJJ20gc28gbGF6eVxuICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgbGV0IGRhdGFUb1dyaXRlID0gW107XG4gICAgZnVuY3Rpb24gd3JpdGVEYXRhKGJ5dGVzKSB7XG4gICAgICAgIGRhdGFUb1dyaXRlID0gZGF0YVRvV3JpdGUuY29uY2F0KGJ5dGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maXJtV3JpdGUoKSB7XG4gICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhVG9Xcml0ZS5sZW5ndGgpO1xuICAgICAgICBvdXRwdXREYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIpO1xuICAgICAgICAvLyBUaGVuIHdyaXRlIHRoZSBkYXRhXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVRvV3JpdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KHBvc2l0aW9uLCBkYXRhVG9Xcml0ZVtpXSk7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgdGltZXN0YW1wIHRvIGEgTUlESSBmaWxlLlxuICAgIGZ1bmN0aW9uIHdyaXRlVGltZSh0aW1lKSB7XG4gICAgICAgIGxldCBidWZmZXIgPSB0aW1lICYgMHg3RjtcbiAgICAgICAgbGV0IHdyaXRldmFsO1xuXG4gICAgICAgIHdoaWxlICgodGltZSA+Pj0gNykgIT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyIDw8PSA4O1xuICAgICAgICAgICAgYnVmZmVyIHw9ICgodGltZSAmIDB4N0YpIHwgMHg4MCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgOykge1xuICAgICAgICAgICAgd3JpdGV2YWwgPSAoYnVmZmVyICYgMHhGRik7XG5cbiAgICAgICAgICAgIHdyaXRlRGF0YShbd3JpdGV2YWxdKTtcblxuICAgICAgICAgICAgdHJhY2tzaXplICs9IDE7XG5cbiAgICAgICAgICAgIGlmICgoYnVmZmVyICYgMHg4MCkgIT0gMCkgeyBidWZmZXIgPj49IDg7IH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVkdGltZSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgdGhlIGVuZCBvZiB0cmFjayBtYXJrZXJcbiAgICBmdW5jdGlvbiB3cml0ZUVuZFRyYWNrKCkge1xuICAgICAgICBjb25zdCBlbmR0cmFjayA9IFsweEZGLCAweDJGLCAweDAwXTtcblxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgd3JpdGVEYXRhKGVuZHRyYWNrKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIGtleSBwcmVzcyBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlUHJlc3NLZXkoY2hhbm5lbCwga2V5LCB2ZWxvY2l0eSkge1xuICAgICAgICAvLyBXcml0ZSBxdWV1ZWQgdGltZVxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgLy8gV3JpdGUgcHJlc3NlZCBrZXkgYW5kIGNoYW5uZWxcbiAgICAgICAgbGV0IHdvcmtpbmcgPSBNSURJX1BSRVNTX0tFWSB8IGNoYW5uZWw7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIC8vIFdyaXRlIGtleVxuICAgICAgICB3b3JraW5nID0ga2V5ICYgMHg3RjtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgLy8gV2l0ZSB2ZWxvY2l0eVxuICAgICAgICB3b3JraW5nID0gdmVsb2NpdHkgJiAweDdGO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIGtleSByZWxlYXNlIGV2ZW50XG4gICAgZnVuY3Rpb24gd3JpdGVSZWxlYXNlS2V5KGNoYW5uZWwsIGtleSkge1xuICAgICAgICAvLyBXcml0ZSBxdWV1ZWQgdGltZVxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgLy8gV3JpdGUgcmVsZWFzZWQga2V5XG4gICAgICAgIGxldCB3b3JraW5nID0gTUlESV9SRUxFQVNFX0tFWSB8IGNoYW5uZWw7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIC8vIFdyaXRlIGtleVxuICAgICAgICB3b3JraW5nID0ga2V5ICYgMHg3RjtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgLy8gRHVtbXlcbiAgICAgICAgd29ya2luZyA9IDA7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHRyYWNrc2l6ZSArPSAzO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIGEgcGl0Y2ggd2hlZWwvYmVuZCBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlUGl0Y2hXaGVlbChjaGFubmVsLCB3aGVlbCkge1xuICAgICAgICAvLyBXcml0ZSBxdWV1ZWQgdGltZVxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgbGV0IHdvcmtpbmcgPSBNSURJX1BJVENIX1dIRUVMIHwgY2hhbm5lbDtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgd29ya2luZyA9IHdoZWVsICYgMHg3RjtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgd29ya2luZyA9ICh3aGVlbCA+PiA3KSAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHRyYWNrc2l6ZSArPSAzO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIGEgcGF0Y2ggY2hhbmdlIGV2ZW50XG4gICAgZnVuY3Rpb24gd3JpdGVDaGFuZ2VQYXRjaChjaGFubmVsLCBwYXRjaCkge1xuICAgICAgICAvLyBXcml0ZSBxdWV1ZWQgdGltZVxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgbGV0IHdvcmtpbmcgPSBNSURJX0NIQU5HRV9QQVRDSCB8IGNoYW5uZWw7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHdvcmtpbmcgPSBwYXRjaCAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHRyYWNrc2l6ZSArPSAyO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIGEgdmFsdWVkIGNvbnRyb2xsZXIgY2hhbmdlIGV2ZW50XG4gICAgZnVuY3Rpb24gd3JpdGVDaGFuZ2VDb250cm9sbGVyVmFsdWVkKGNoYW5uZWwsIGNvbnRyb2wsIHZhbHVlKSB7XG4gICAgICAgIC8vIFdyaXRlIHF1ZXVlZCB0aW1lXG4gICAgICAgIHdyaXRlVGltZShxdWV1ZWR0aW1lKTtcblxuICAgICAgICBsZXQgd29ya2luZyA9IE1JRElfQ0hBTkdFX0NPTlRST0xMRVIgfCBjaGFubmVsO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB3b3JraW5nID0gY29udHJvbCAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIC8vIFF1aXJrIGluIHZhbmlsbGEgRE9PTT8gTVVTIGNvbnRyb2xsZXIgdmFsdWVzIHNob3VsZCBiZSA3LWJpdCwgbm90IDgtYml0LlxuICAgICAgICB3b3JraW5nID0gdmFsdWUgJiAweDgwID8gMHg3RiA6IHZhbHVlO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIHZhbHVlbGVzcyBjb250cm9sbGVyIGNoYW5nZSBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlQ2hhbmdlQ29udHJvbGxlclZhbHVlbGVzcyhjaGFubmVsLCBjb250cm9sKSB7XG4gICAgICAgIHdyaXRlQ2hhbmdlQ29udHJvbGxlclZhbHVlZChjaGFubmVsLCBjb250cm9sLCAwKTtcbiAgICB9XG5cbiAgICAvLyBBbGxvY2F0ZSBhIGZyZWUgTUlESSBjaGFubmVsLlxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlTUlESUNoYW5uZWwoKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGxldCBpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGN1cnJlbnQgaGlnaGVzdC1hbGxvY2F0ZWQgY2hhbm5lbC5cblxuICAgICAgICBtYXggPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTVVTX05VTV9DSEFOTkVMUzsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbE1hcFtpXSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGNoYW5uZWxNYXBbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXggaXMgbm93IGVxdWFsIHRvIHRoZSBoaWdoZXN0LWFsbG9jYXRlZCBNSURJIGNoYW5uZWwuICBXZSBjYW5cbiAgICAgICAgLy8gbm93IGFsbG9jYXRlIHRoZSBuZXh0IGF2YWlsYWJsZSBjaGFubmVsLiAgVGhpcyBhbHNvIHdvcmtzIGlmXG4gICAgICAgIC8vIG5vIGNoYW5uZWxzIGFyZSBjdXJyZW50bHkgYWxsb2NhdGVkIChtYXg9LTEpXG5cbiAgICAgICAgcmVzdWx0ID0gbWF4ICsgMTtcblxuICAgICAgICAvLyBEb24ndCBhbGxvY2F0ZSB0aGUgTUlESSBwZXJjdXNzaW9uIGNoYW5uZWwhXG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTUlESV9QRVJDVVNTSU9OX0NIQU5ORUwpIHtcbiAgICAgICAgICAgICsrcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBHaXZlbiBhIE1VUyBjaGFubmVsIG51bWJlciwgZ2V0IHRoZSBNSURJIGNoYW5uZWwgbnVtYmVyIHRvIHVzZSBpbiB0aGUgb3V0cHV0dGVkIGZpbGUuXG4gICAgZnVuY3Rpb24gZ2V0TUlESUNoYW5uZWwobXVzQ2hhbm5lbCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBNSURJIGNoYW5uZWwgdG8gdXNlIGZvciB0aGlzIE1VUyBjaGFubmVsLlxuICAgICAgICAvLyBNVVMgY2hhbm5lbCAxNSBpcyB0aGUgcGVyY3Vzc3Npb24gY2hhbm5lbC5cblxuICAgICAgICBpZiAobXVzQ2hhbm5lbCA9PT0gTVVTX1BFUkNVU1NJT05fQ0hBTk5FTCkge1xuICAgICAgICAgICAgcmV0dXJuIE1JRElfUEVSQ1VTU0lPTl9DSEFOTkVMO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBNSURJIGNoYW5uZWwgaGFzbid0IGJlZW4gYWxsb2NhdGVkIGZvciB0aGlzIE1VUyBjaGFubmVsXG4gICAgICAgIC8vIHlldCwgYWxsb2NhdGUgdGhlIG5leHQgZnJlZSBNSURJIGNoYW5uZWwuXG5cbiAgICAgICAgaWYgKGNoYW5uZWxNYXBbbXVzQ2hhbm5lbF0gPT09IC0xKSB7XG4gICAgICAgICAgICBjaGFubmVsTWFwW211c0NoYW5uZWxdID0gYWxsb2NhdGVNSURJQ2hhbm5lbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5uZWxNYXBbbXVzQ2hhbm5lbF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZE11c0hlYWRlcihkYXRhVmlldykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuY3JlYXRlKG11c2hlYWRlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dC5pZC5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2NvcmVsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoNCwgdHJ1ZSk7XG4gICAgICAgIG91dHB1dC5zY29yZXN0YXJ0ID0gZGF0YVZpZXcuZ2V0VWludDE2KDYsIHRydWUpO1xuICAgICAgICBvdXRwdXQucHJpbWFyeWNoYW5uZWxzID0gZGF0YVZpZXcuZ2V0VWludDE2KDgsIHRydWUpO1xuICAgICAgICBvdXRwdXQuc2Vjb25kYXJ5Y2hhbm5lbHMgPSBkYXRhVmlldy5nZXRVaW50MTYoMTAsIHRydWUpO1xuICAgICAgICBvdXRwdXQuaW5zdHJ1bWVudGNvdW50ID0gZGF0YVZpZXcuZ2V0VWludDE2KDEyLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRNdXNUb01pZGkobXVzaW5wdXQpIHtcbiAgICAgICAgLy8gbWFzdGVyIGRhdGF2aWV3IGZvciBpbnB1dCBtdXNcbiAgICAgICAgbXVzRGF0YVZpZXcgPSBtdXNpbnB1dDtcbiAgICAgICAgbXVzRGF0YVBvc2l0aW9uID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBnZXRNdXNCeXRlOCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG11c0RhdGFWaWV3LmdldFVpbnQ4KG11c0RhdGFQb3NpdGlvbik7XG4gICAgICAgICAgICBtdXNEYXRhUG9zaXRpb24gKz0gMTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG91dHB1dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFzdGVyIGRhdGEgZm9yIG91dHB1dCBtaWRpXG4gICAgICAgIGNvbnN0IG91dHB1dEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICBvdXRwdXREYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRwdXRBcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgLy8gRGVzY3JpcHRvciBmb3IgdGhlIGN1cnJlbnQgTVVTIGV2ZW50XG4gICAgICAgIGxldCBldmVudGRlc2NyaXB0b3I7XG4gICAgICAgIGxldCBjaGFubmVsOyAvLyBDaGFubmVsIG51bWJlclxuICAgICAgICBsZXQgbXVzRXZlbnQ7XG5cblxuICAgICAgICAvLyBCdW5jaCBvZiB2YXJzIHJlYWQgZnJvbSBNVVMgbHVtcFxuICAgICAgICBsZXQga2V5O1xuICAgICAgICBsZXQgY29udHJvbGxlcm51bWJlcjtcbiAgICAgICAgbGV0IGNvbnRyb2xsZXJ2YWx1ZTtcblxuICAgICAgICAvLyBGbGFnIGZvciB3aGVuIHRoZSBzY29yZSBlbmQgbWFya2VyIGlzIGhpdC5cbiAgICAgICAgbGV0IGhpdHNjb3JlZW5kID0gMDtcblxuICAgICAgICAvLyBUZW1wIHdvcmtpbmcgYnl0ZVxuICAgICAgICBsZXQgd29ya2luZztcbiAgICAgICAgLy8gVXNlZCBpbiBidWlsZGluZyB1cCB0aW1lIGRlbGF5c1xuICAgICAgICBsZXQgdGltZWRlbGF5O1xuXG4gICAgICAgIC8vIEluaXRpYWxpc2UgY2hhbm5lbCBtYXAgdG8gbWFyayBhbGwgY2hhbm5lbHMgYXMgdW51c2VkLlxuICAgICAgICBmb3IgKGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgTVVTX05VTV9DSEFOTkVMUzsgKytjaGFubmVsKSB7XG4gICAgICAgICAgICBjaGFubmVsTWFwW2NoYW5uZWxdID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHcmFiIHRoZSBoZWFkZXJcbiAgICAgICAgY29uc3QgbXVzZmlsZWhlYWRlciA9IHJlYWRNdXNIZWFkZXIobXVzRGF0YVZpZXcpO1xuICAgICAgICAvLyBDaGVjayBNVVMgaGVhZGVyXG4gICAgICAgIGlmIChtdXNmaWxlaGVhZGVyLmlkWzBdICE9PSAnTScuY2hhckNvZGVBdCgwKSB8fCBtdXNmaWxlaGVhZGVyLmlkWzFdICE9PSAnVScuY2hhckNvZGVBdCgwKVxuICAgICAgICAgICAgfHwgbXVzZmlsZWhlYWRlci5pZFsyXSAhPT0gJ1MnLmNoYXJDb2RlQXQoMCkgfHwgbXVzZmlsZWhlYWRlci5pZFszXSAhPT0gMHgxQSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBNVVMgaGVhZGVyLicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlayB0byB3aGVyZSB0aGUgZGF0YSBpcyBoZWxkXG4gICAgICAgIG11c0RhdGFQb3NpdGlvbiA9IG11c2ZpbGVoZWFkZXIuc2NvcmVzdGFydDtcbiAgICAgICAgLy8gU28sIHdlIGNhbiBhc3N1bWUgdGhlIE1VUyBmaWxlIGlzIGZhaW50bHkgbGVnaXQuIExldCdzIHN0YXJ0IHdyaXRpbmcgTUlESSBkYXRhLi4uXG5cbiAgICAgICAgd3JpdGVEYXRhKE1JRElfSEVBREVSX0RBVEEpO1xuICAgICAgICB0cmFja3NpemUgPSAwO1xuXG4gICAgICAgIC8vIE5vdywgcHJvY2VzcyB0aGUgTVVTIGZpbGU6XG4gICAgICAgIHdoaWxlIChoaXRzY29yZWVuZCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGEgYmxvY2sgb2YgZXZlbnRzOlxuXG4gICAgICAgICAgICB3aGlsZSAoaGl0c2NvcmVlbmQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBjaGFubmVsIG51bWJlciBhbmQgZXZlbnQgY29kZTpcbiAgICAgICAgICAgICAgICBldmVudGRlc2NyaXB0b3IgPSBnZXRNdXNCeXRlOCgpO1xuXG5cbiAgICAgICAgICAgICAgICBjaGFubmVsID0gZ2V0TUlESUNoYW5uZWwoZXZlbnRkZXNjcmlwdG9yICYgMHgwRik7XG4gICAgICAgICAgICAgICAgbXVzRXZlbnQgPSBldmVudGRlc2NyaXB0b3IgJiAweDcwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobXVzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1VU19SRUxFQVNFX0tFWTpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ01VU19SRUxFQVNFX0tFWScpO1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZXRNdXNCeXRlOCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUmVsZWFzZUtleShjaGFubmVsLCBrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBNVVNfUFJFU1NfS0VZOlxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZXRNdXNCeXRlOCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsdmVsb2NpdGllc1tjaGFubmVsXSA9IGdldE11c0J5dGU4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx2ZWxvY2l0aWVzW2NoYW5uZWxdICY9IDB4N0Y7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfUFJFU1NfS0VZOiAnK2tleSsgJyAnICsgY2hhbm5lbHZlbG9jaXRpZXNbY2hhbm5lbF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ01VU19QUkVTU19LRVk6ICcra2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUHJlc3NLZXkoY2hhbm5lbCwga2V5LCBjaGFubmVsdmVsb2NpdGllc1tjaGFubmVsXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIE1VU19QSVRDSF9XSEVFTDpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ01VU19QSVRDSF9XSEVFTCcpO1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZXRNdXNCeXRlOCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUGl0Y2hXaGVlbChjaGFubmVsLCBrZXkgKiA2NCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIE1VU19TWVNURU1fRVZFTlQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfU1lTVEVNX0VWRU5UJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJudW1iZXIgPSBnZXRNdXNCeXRlOCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVybnVtYmVyIDwgMTAgfHwgY29udHJvbGxlcm51bWJlciA+IDE0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb250cm9sbGVyIG51bWJlciBpbmFjY3VyYXRlIDEwLTE0OiAke2NvbnRyb2xsZXJudW1iZXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3cml0ZUNoYW5nZUNvbnRyb2xsZXJWYWx1ZWxlc3MoY2hhbm5lbCwgTUlESV9DT05UUk9MTEVSX01BUFtjb250cm9sbGVybnVtYmVyXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIE1VU19DSEFOR0VfQ09OVFJPTExFUjpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcm51bWJlciA9IGdldE11c0J5dGU4KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJ2YWx1ZSA9IGdldE11c0J5dGU4KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfQ0hBTkdFX0NPTlRST0xMRVI6ICcgK2NvbnRyb2xsZXJudW1iZXIrJyAnK2NvbnRyb2xsZXJ2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVybnVtYmVyID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQ2hhbmdlUGF0Y2goY2hhbm5lbCwgY29udHJvbGxlcnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVybnVtYmVyIDwgMSB8fCBjb250cm9sbGVybnVtYmVyID4gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvbnRyb2xsZXIgbnVtYmVyIGluYWNjdXJhdGU6ICR7Y29udHJvbGxlcm51bWJlcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQ2hhbmdlQ29udHJvbGxlclZhbHVlZChjaGFubmVsLCBNSURJX0NPTlRST0xMRVJfTUFQW2NvbnRyb2xsZXJudW1iZXJdLCBjb250cm9sbGVydmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIE1VU19TQ09SRV9FTkQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXNTY29yZUVuZCcpO1xuICAgICAgICAgICAgICAgICAgICBoaXRzY29yZWVuZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2V2ZW50ZGVzY3JpcHRvciBkZWZhdWx0OiAnK2V2ZW50ZGVzY3JpcHRvciArICcgJyArIChldmVudGRlc2NyaXB0b3IgJiAweDgwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChldmVudGRlc2NyaXB0b3IgJiAweDgwKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWxheSBjb3VudCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byByZWFkIHRoZSB0aW1lIGNvZGU6XG4gICAgICAgICAgICBpZiAoaGl0c2NvcmVlbmQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVhZCB0aW1lIGNvZGUnKTtcbiAgICAgICAgICAgICAgICB0aW1lZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgIC8vIGRlbGF5Q291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGdldE11c0J5dGU4KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGF5Q291bnRlciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aW1lZGVsYXkgPSB0aW1lZGVsYXkgKiAxMjggKyAod29ya2luZyAmIDB4N0YpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHdvcmtpbmcgJiAweDgwKSA9PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWxheSBjb3VudDogJytkZWxheUNvdW50ZXIgKyAnIHRpbWUgZGVsYXk6ICcgKyB0aW1lZGVsYXkpXG4gICAgICAgICAgICAgICAgcXVldWVkdGltZSArPSB0aW1lZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYENvbnZlcnRlZCAnJHtsdW1wSWR9JyBmcm9tIE1VUyB0byBNSURJIChXQUQ6ICcke3dhZElkfScpLmApO1xuICAgICAgICAvLyBFbmQgb2YgdHJhY2tcbiAgICAgICAgd3JpdGVFbmRUcmFjaygpO1xuXG4gICAgICAgIGNvbmZpcm1Xcml0ZSgpO1xuXG4gICAgICAgIC8vIFdyaXRlIHRoZSB0cmFjayBzaXplIGludG8gdGhlIHN0cmVhbVxuICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChNSURJX1RSQUNLTEVOR1RIX09GUyArIDAsICh0cmFja3NpemUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KE1JRElfVFJBQ0tMRU5HVEhfT0ZTICsgMSwgKHRyYWNrc2l6ZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgb3V0cHV0RGF0YVZpZXcuc2V0VWludDgoTUlESV9UUkFDS0xFTkdUSF9PRlMgKyAyLCAodHJhY2tzaXplID4+IDgpICYgMHhmZik7XG4gICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KE1JRElfVFJBQ0tMRU5HVEhfT0ZTICsgMywgdHJhY2tzaXplICYgMHhmZik7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dERhdGFWaWV3LmJ1ZmZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXN0ZXJPdXRwdXQgPSBjb252ZXJ0TXVzVG9NaWRpKGRhdGEpO1xuICAgIGlmIChtYXN0ZXJPdXRwdXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjb252ZXJ0ICcke2x1bXBJZH0nIGZyb20gTVVTIHRvIE1JREkgKFdBRDogJyR7d2FkSWR9JykuYCwgeyBtdXNEYXRhUG9zaXRpb24gfSk7XG4gICAgfVxuXG4gICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICB3YWRJZCxcbiAgICAgICAgbHVtcElkLFxuICAgICAgICBtaWRpOiBtYXN0ZXJPdXRwdXQsXG4gICAgfSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFPQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBYUE7QUFFQTtBQUVBO0FBSUE7QUFRQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQVFBO0FBRUE7QUFLQTtBQUdBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);