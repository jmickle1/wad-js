!function(g){var I={};function C(A){if(I[A])return I[A].exports;var n=I[A]={i:A,l:!1,exports:{}};return g[A].call(n.exports,n,n.exports,C),n.l=!0,n.exports}C.m=g,C.c=I,C.d=function(g,I,A){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:A})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var n in g)C.d(A,n,function(I){return g[I]}.bind(null,n));return A},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./app/lib/constants.js\nvar TEXT = 'text';\nvar MAPDATA = 'mapdata';\nvar MUSIC = 'music';\nvar MIDI = 'midi';\nvar MP3 = 'mp3';\nvar PNG = 'png';\nvar MUS = 'mus';\nvar GRAPHIC = 'graphic';\nvar FLAT = 'flat';\nvar MARKER = 'marker';\nvar ENDOOM = 'ENDOOM';\nvar TEXTUREx = ['TEXTURE1', 'TEXTURE2'];\nvar TEXTLUMPS = ['DEHACKED', 'MAPINFO', 'ZMAPINFO', 'EMAPINFO', 'DMXGUS', 'DMXGUSC', 'WADINFO', 'EMENUS', 'MUSINFO', 'SNDINFO', 'GLDEFS', 'KEYCONF', 'SCRIPTS', 'LANGUAGE', 'DECORATE', 'SBARINFO', 'MENUDEF'];\nvar DATA_LUMPS = ['PLAYPAL', 'COLORMAP', 'TEXTURE1', 'TEXTURE2', 'PNAMES', 'ENDOOM'];\nvar DEFAULT_EXTENSION = 'lmp';\nvar EXTENSIONS = {\n  text: 'txt',\n  mp3: 'mp3',\n  mus: 'mus',\n  midi: 'mid',\n  png: 'png'\n};\nvar IWAD = 'IWAD';\nvar PWAD = 'PWAD';\nvar VALID_WAD_TYPES = [IWAD, PWAD];\nvar SUPPORTED_FORMATS = ['.wad', '.zip', '.pk3', '.json'];\nvar VALID_FILE_FORMATS = ['', 'application/x-doom', 'application/zip', 'application/json'];\n/* Lump types */\n\nvar MAP = 'maps';\nvar INTERMISSION = 'intermission';\nvar STATUS_BAR = 'status bar';\nvar MENU = 'menu';\nvar IMAGE_LUMPS = ['patches', 'flats', 'sprites', MENU, INTERMISSION, STATUS_BAR];\nvar UNCATEGORIZED = 'uncategorized';\n/* Lump names */\n\nvar THINGS = 'THINGS';\nvar TEXTMAP = 'TEXTMAP';\nvar ENDMAP = 'ENDMAP';\nvar MAP_LUMPS = [THINGS, 'LINEDEFS', 'SIDEDEFS', 'VERTEXES', 'SEGS', 'TEXTMAP', 'SSECTORS', 'NODES', 'SECTORS', 'REJECT', 'BLOCKMAP', // Hexen only\n'BEHAVIOR', // ZDoom only? (optional)\n'SCRIPTS', // Universal Doom Map Format only\n'ZNODES', 'DIALOGUE'];\nvar OPENGL_MAP_LUMPS = ['GL_VERT', 'GL_SEGS', 'GL_SSECT', 'GL_NODES', 'GL_PVS'];\nvar INTERMISSION_LUMPS = new RegExp(/WI[0-9a-zA-Z_]{1,}$/);\nvar STATUS_BAR_LUMPS = new RegExp(/(ST|AMM|BRDR_)[0-9a-zA-Z_]{1,}$/);\n/* Unique lumps */\n\nvar MAPINFO = ['MAPINFO', 'ZMAPINFO'];\nvar PLAYPAL = 'PLAYPAL';\nvar COLORMAP = 'COLORMAP';\nvar PNAMES = 'PNAMES';\nvar SBARINFO = 'SBARINFO';\nvar MENU_SCREENS = ['TITLEPIC', 'HELP', 'HELP1', 'HELP2', 'CREDIT'];\nvar INTERMISSION_SCREEN = 'INTERPIC';\nvar MUSIC_LUMPS = ['GENMIDI', 'DMXGUS', 'DMXGUSC', // Hexen only\n'SNDINFO'];\nvar DEMO_LUMPS = ['DEMO1', 'DEMO2', 'DEMO3', 'DEMO4'];\nvar LUMP_INDEX_ENTRY_SIZE = 16;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_SIZE = 4;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_NAME = 8;\nvar COLOR_COUNT_PER_PALETTE = 256;\nvar PALETTE_SIZE = 768;\nvar COLORMAP_SIZE = 256;\nvar BYTES_PER_COLOR = 3;\nvar GREEN_COLOR_OFFSET = 1;\nvar BLUE_COLOR_OFFSET = 2;\nvar FLAT_DIMENSIONS = 64;\nvar IMAGE_DATA_HEADER_SIZE = 8;\nvar IMAGE_DATA_BOUNDARY = 255;\nvar TRANSPARENT_PIXEL = -1;\n/* MUS -> MIDI conversion */\n\nvar MUS_HEADER = 'MUS';\nvar MIDI_HEADER = 'MThd';\nvar MIDI_HEADER_SIZE = 4;\nvar MIDI_HEADER_DATA = ['M'.charCodeAt(0), 'T'.charCodeAt(0), 'h'.charCodeAt(0), 'd'.charCodeAt(0), // Main header\n0x00, 0x00, 0x00, 0x06, // Header size\n0x00, 0x00, // MIDI type (0)\n0x00, 0x01, // Number of tracks\n0x00, 0x46, // Resolution\n'M'.charCodeAt(0), 'T'.charCodeAt(0), 'r'.charCodeAt(0), 'k'.charCodeAt(0), // Start of track\n0x00, 0x00, 0x00, 0x00];\nvar MUS_NUM_CHANNELS = 16;\nvar MUS_PERCUSSION_CHANNEL = 15;\nvar MIDI_PERCUSSION_CHANNEL = 9;\nvar MIDI_TRACKLENGTH_OFS = 18;\nvar MIDI_CONTROLLER_MAP = [0x00, 0x20, 0x01, 0x07, 0x0A, 0x0B, 0x5B, 0x5D, 0x40, 0x43, 0x78, 0x7B, 0x7E, 0x7F, 0x79]; // MUS event codes\n\nvar MUS_RELEASE_KEY = 0x00;\nvar MUS_PRESS_KEY = 0x10;\nvar MUS_PITCH_WHEEL = 0x20;\nvar MUS_SYSTEM_EVENT = 0x30;\nvar MUS_CHANGE_CONTROLLER = 0x40;\nvar MUS_SCORE_END = 0x60; // MIDI event codes\n\nvar MIDI_RELEASE_KEY = 0x80;\nvar MIDI_PRESS_KEY = 0x90;\nvar MIDI_CHANGE_CONTROLLER = 0xB0;\nvar MIDI_CHANGE_PATCH = 0xC0;\nvar MIDI_PITCH_WHEEL = 0xE0;\n// CONCATENATED MODULE: ./app/workers/midiConverter.js\n\n\n// TODO: Send the error string in postMessage\n\nonmessage = (message) => {\n    const { wadId, lumpId, data } = message.data;\n\n    console.log(`Converting '${lumpId}' from MUS to MIDI (WAD: '${wadId}') ...`);\n\n    // Structure to hold MUS file header\n    const musheader = {\n        id: [],\n        scorelength: null,\n        scorestart: null,\n        primarychannels: null,\n        secondarychannels: null,\n        instrumentcount: null,\n    };\n\n    let musDataView;\n    let musDataPosition;\n\n    // Cached channel velocities\n    const channelvelocities = [\n        127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,\n    ];\n\n    // Timestamps between sequences of MUS events\n    let queuedtime = 0;\n\n    // Counter for the length of the track\n    let tracksize;\n\n    const channelMap = [];\n\n    // Main DataView for writing to. This is used by writeData();\n    let outputDataView;\n\n    // Wrapper function to work like slade's memchunk.write()\n    // I'm so lazy\n    let position = 0;\n    let dataToWrite = [];\n    function writeData(bytes) {\n        dataToWrite = dataToWrite.concat(bytes);\n    }\n\n    function confirmWrite() {\n        const newBuffer = new ArrayBuffer(dataToWrite.length);\n        outputDataView = new DataView(newBuffer);\n        // Then write the data\n        for (let i = 0; i < dataToWrite.length; i++) {\n            outputDataView.setUint8(position, dataToWrite[i]);\n            position += 1;\n        }\n    }\n\n    // Write timestamp to a MIDI file.\n    function writeTime(time) {\n        let buffer = time & 0x7F;\n        let writeval;\n\n        while ((time >>= 7) != 0) {\n            buffer <<= 8;\n            buffer |= ((time & 0x7F) | 0x80);\n        }\n\n        for (; ;) {\n            writeval = (buffer & 0xFF);\n\n            writeData([writeval]);\n\n            tracksize += 1;\n\n            if ((buffer & 0x80) != 0) { buffer >>= 8; } else {\n                queuedtime = 0;\n                return;\n            }\n        }\n    }\n\n    // Write the end of track marker\n    function writeEndTrack() {\n        const endtrack = [0xFF, 0x2F, 0x00];\n\n        writeTime(queuedtime);\n\n        writeData(endtrack);\n\n        tracksize += 3;\n    }\n\n    // Write a key press event\n    function writePressKey(channel, key, velocity) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        // Write pressed key and channel\n        let working = MIDI_PRESS_KEY | channel;\n        writeData([working]);\n\n        // Write key\n        working = key & 0x7F;\n        writeData([working]);\n\n        // Wite velocity\n        working = velocity & 0x7F;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a key release event\n    function writeReleaseKey(channel, key) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        // Write released key\n        let working = MIDI_RELEASE_KEY | channel;\n        writeData([working]);\n\n        // Write key\n        working = key & 0x7F;\n        writeData([working]);\n\n        // Dummy\n        working = 0;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a pitch wheel/bend event\n    function writePitchWheel(channel, wheel) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = MIDI_PITCH_WHEEL | channel;\n        writeData([working]);\n\n        working = wheel & 0x7F;\n        writeData([working]);\n\n        working = (wheel >> 7) & 0x7F;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a patch change event\n    function writeChangePatch(channel, patch) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = MIDI_CHANGE_PATCH | channel;\n        writeData([working]);\n\n        working = patch & 0x7F;\n        writeData([working]);\n\n        tracksize += 2;\n    }\n\n    // Write a valued controller change event\n    function writeChangeControllerValued(channel, control, value) {\n        // Write queued time\n        writeTime(queuedtime);\n\n        let working = MIDI_CHANGE_CONTROLLER | channel;\n        writeData([working]);\n\n        working = control & 0x7F;\n        writeData([working]);\n\n        // Quirk in vanilla DOOM? MUS controller values should be 7-bit, not 8-bit.\n        working = value & 0x80 ? 0x7F : value;\n        writeData([working]);\n\n        tracksize += 3;\n    }\n\n    // Write a valueless controller change event\n    function writeChangeControllerValueless(channel, control) {\n        writeChangeControllerValued(channel, control, 0);\n    }\n\n    // Allocate a free MIDI channel.\n    function allocateMIDIChannel() {\n        let result;\n        let max;\n        let i;\n\n        // Find the current highest-allocated channel.\n\n        max = -1;\n\n        for (i = 0; i < MUS_NUM_CHANNELS; ++i) {\n            if (channelMap[i] > max) {\n                max = channelMap[i];\n            }\n        }\n\n        // max is now equal to the highest-allocated MIDI channel.  We can\n        // now allocate the next available channel.  This also works if\n        // no channels are currently allocated (max=-1)\n\n        result = max + 1;\n\n        // Don't allocate the MIDI percussion channel!\n\n        if (result === MIDI_PERCUSSION_CHANNEL) {\n            ++result;\n        }\n\n        return result;\n    }\n\n    // Given a MUS channel number, get the MIDI channel number to use in the outputted file.\n    function getMIDIChannel(musChannel) {\n        // Find the MIDI channel to use for this MUS channel.\n        // MUS channel 15 is the percusssion channel.\n\n        if (musChannel === MUS_PERCUSSION_CHANNEL) {\n            return MIDI_PERCUSSION_CHANNEL;\n        }\n\n        // If a MIDI channel hasn't been allocated for this MUS channel\n        // yet, allocate the next free MIDI channel.\n\n        if (channelMap[musChannel] === -1) {\n            channelMap[musChannel] = allocateMIDIChannel();\n        }\n\n        return channelMap[musChannel];\n    }\n\n    function readMusHeader(dataView) {\n        const output = Object.create(musheader);\n\n        for (let i = 0; i < 4; i++) {\n            output.id.push(dataView.getUint8(i));\n        }\n        output.scorelength = dataView.getUint16(4, true);\n        output.scorestart = dataView.getUint16(6, true);\n        output.primarychannels = dataView.getUint16(8, true);\n        output.secondarychannels = dataView.getUint16(10, true);\n        output.instrumentcount = dataView.getUint16(12, true);\n\n        return output;\n    }\n\n    function convertMusToMidi(musinput) {\n        // master dataview for input mus\n        musDataView = musinput;\n        musDataPosition = 0;\n\n        function getMusByte8() {\n            const output = musDataView.getUint8(musDataPosition);\n            musDataPosition += 1;\n            // console.log(output);\n            return output;\n        }\n\n        // master data for output midi\n        const outputArrayBuffer = new ArrayBuffer(0);\n        outputDataView = new DataView(outputArrayBuffer);\n\n        // Descriptor for the current MUS event\n        let eventdescriptor;\n        let channel; // Channel number\n        let musEvent;\n\n\n        // Bunch of vars read from MUS lump\n        let key;\n        let controllernumber;\n        let controllervalue;\n\n        // Flag for when the score end marker is hit.\n        let hitscoreend = 0;\n\n        // Temp working byte\n        let working;\n        // Used in building up time delays\n        let timedelay;\n\n        // Initialise channel map to mark all channels as unused.\n        for (channel = 0; channel < MUS_NUM_CHANNELS; ++channel) {\n            channelMap[channel] = -1;\n        }\n\n        // Grab the header\n        const musfileheader = readMusHeader(musDataView);\n        // Check MUS header\n        if (musfileheader.id[0] !== 'M'.charCodeAt(0) || musfileheader.id[1] !== 'U'.charCodeAt(0)\n            || musfileheader.id[2] !== 'S'.charCodeAt(0) || musfileheader.id[3] !== 0x1A) {\n            console.error('Invalid MUS header.');\n            return false;\n        }\n\n        // Seek to where the data is held\n        musDataPosition = musfileheader.scorestart;\n        // So, we can assume the MUS file is faintly legit. Let's start writing MIDI data...\n\n        writeData(MIDI_HEADER_DATA);\n        tracksize = 0;\n\n        // Now, process the MUS file:\n        while (hitscoreend === 0) {\n            // Handle a block of events:\n\n            while (hitscoreend === 0) {\n                // Fetch channel number and event code:\n                eventdescriptor = getMusByte8();\n\n\n                channel = getMIDIChannel(eventdescriptor & 0x0F);\n                musEvent = eventdescriptor & 0x70;\n                switch (musEvent) {\n                case MUS_RELEASE_KEY:\n                    // console.log('MUS_RELEASE_KEY');\n                    key = getMusByte8();\n\n                    writeReleaseKey(channel, key);\n\n                    break;\n\n                case MUS_PRESS_KEY:\n                    key = getMusByte8();\n\n                    if (key & 0x80) {\n                        channelvelocities[channel] = getMusByte8();\n\n                        channelvelocities[channel] &= 0x7F;\n\n                        // console.log('MUS_PRESS_KEY: '+key+ ' ' + channelvelocities[channel]);\n                    } else {\n                        // console.log('MUS_PRESS_KEY: '+key);\n                    }\n\n                    writePressKey(channel, key, channelvelocities[channel]);\n\n                    break;\n\n                case MUS_PITCH_WHEEL:\n                    // console.log('MUS_PITCH_WHEEL');\n                    key = getMusByte8();\n\n                    writePitchWheel(channel, key * 64);\n\n                    break;\n\n                case MUS_SYSTEM_EVENT:\n                    // console.log('MUS_SYSTEM_EVENT');\n                    controllernumber = getMusByte8();\n\n                    if (controllernumber < 10 || controllernumber > 14) {\n                        console.error(`Controller number inaccurate 10-14: ${controllernumber}`);\n                        return false;\n                    }\n\n                    writeChangeControllerValueless(channel, MIDI_CONTROLLER_MAP[controllernumber]);\n\n                    break;\n\n                case MUS_CHANGE_CONTROLLER:\n                    controllernumber = getMusByte8();\n                    controllervalue = getMusByte8();\n                    // console.log('MUS_CHANGE_CONTROLLER: ' +controllernumber+' '+controllervalue);\n                    if (controllernumber == 0) {\n                        writeChangePatch(channel, controllervalue);\n                    } else {\n                        if (controllernumber < 1 || controllernumber > 9) {\n                            console.error(`Controller number inaccurate: ${controllernumber}`);\n                            return false;\n                        }\n\n                        writeChangeControllerValued(channel, MIDI_CONTROLLER_MAP[controllernumber], controllervalue);\n                    }\n\n                    break;\n\n                case MUS_SCORE_END:\n                    // console.log('musScoreEnd');\n                    hitscoreend = 1;\n                    break;\n\n                default:\n                    // console.log('eventdescriptor default: '+eventdescriptor + ' ' + (eventdescriptor & 0x80));\n                    return false;\n                }\n                if ((eventdescriptor & 0x80) != 0) {\n                    // console.log('delay count');\n                    break;\n                }\n            }\n            // Now we need to read the time code:\n            if (hitscoreend === 0) {\n                // console.log('read time code');\n                timedelay = 0;\n                // delayCounter = 0;\n                for (; ;) {\n                    working = getMusByte8();\n                    // delayCounter += 1;\n                    timedelay = timedelay * 128 + (working & 0x7F);\n                    if ((working & 0x80) == 0) { break; }\n                }\n                // console.log('delay count: '+delayCounter + ' time delay: ' + timedelay)\n                queuedtime += timedelay;\n            }\n        }\n        console.log(`Converted '${lumpId}' from MUS to MIDI (WAD: '${wadId}').`);\n        // End of track\n        writeEndTrack();\n\n        confirmWrite();\n\n        // Write the track size into the stream\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 0, (tracksize >> 24) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 1, (tracksize >> 16) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 2, (tracksize >> 8) & 0xff);\n        outputDataView.setUint8(MIDI_TRACKLENGTH_OFS + 3, tracksize & 0xff);\n\n        return outputDataView.buffer;\n    }\n\n    const masterOutput = convertMusToMidi(data);\n    if (masterOutput === false) {\n        console.error(`Failed to convert '${lumpId}' from MUS to MIDI (WAD: '${wadId}').`, { musDataPosition });\n    }\n\n    postMessage({\n        wadId,\n        lumpId,\n        midi: masterOutput,\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC9saWIvY29uc3RhbnRzLmpzP2I2NGQiLCJ3ZWJwYWNrOi8vLy4vYXBwL3dvcmtlcnMvbWlkaUNvbnZlcnRlci5qcz8yOTllIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBURVhUID0gJ3RleHQnO1xuZXhwb3J0IGNvbnN0IE1BUERBVEEgPSAnbWFwZGF0YSc7XG5leHBvcnQgY29uc3QgTVVTSUMgPSAnbXVzaWMnO1xuZXhwb3J0IGNvbnN0IE1JREkgPSAnbWlkaSc7XG5leHBvcnQgY29uc3QgTVAzID0gJ21wMyc7XG5leHBvcnQgY29uc3QgUE5HID0gJ3BuZyc7XG5leHBvcnQgY29uc3QgTVVTID0gJ211cyc7XG5leHBvcnQgY29uc3QgR1JBUEhJQyA9ICdncmFwaGljJztcbmV4cG9ydCBjb25zdCBGTEFUID0gJ2ZsYXQnO1xuZXhwb3J0IGNvbnN0IE1BUktFUiA9ICdtYXJrZXInO1xuZXhwb3J0IGNvbnN0IEVORE9PTSA9ICdFTkRPT00nO1xuZXhwb3J0IGNvbnN0IFRFWFRVUkV4ID0gWydURVhUVVJFMScsICdURVhUVVJFMiddO1xuXG5leHBvcnQgY29uc3QgVEVYVExVTVBTID0gWydERUhBQ0tFRCcsICdNQVBJTkZPJywgJ1pNQVBJTkZPJywgJ0VNQVBJTkZPJyxcbiAgICAnRE1YR1VTJywgJ0RNWEdVU0MnLCAnV0FESU5GTycsICdFTUVOVVMnLCAnTVVTSU5GTycsXG4gICAgJ1NORElORk8nLCAnR0xERUZTJywgJ0tFWUNPTkYnLCAnU0NSSVBUUycsICdMQU5HVUFHRScsXG4gICAgJ0RFQ09SQVRFJywgJ1NCQVJJTkZPJywgJ01FTlVERUYnXTtcbmV4cG9ydCBjb25zdCBEQVRBX0xVTVBTID0gWydQTEFZUEFMJywgJ0NPTE9STUFQJywgJ1RFWFRVUkUxJywgJ1RFWFRVUkUyJywgJ1BOQU1FUycsXG4gICAgJ0VORE9PTSddO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9FWFRFTlNJT04gPSAnbG1wJztcbmV4cG9ydCBjb25zdCBFWFRFTlNJT05TID0ge1xuICAgIHRleHQ6ICd0eHQnLFxuICAgIG1wMzogJ21wMycsXG4gICAgbXVzOiAnbXVzJyxcbiAgICBtaWRpOiAnbWlkJyxcbiAgICBwbmc6ICdwbmcnLFxufTtcblxuXG5leHBvcnQgY29uc3QgSVdBRCA9ICdJV0FEJztcbmV4cG9ydCBjb25zdCBQV0FEID0gJ1BXQUQnO1xuZXhwb3J0IGNvbnN0IFZBTElEX1dBRF9UWVBFUyA9IFtJV0FELCBQV0FEXTtcblxuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9GT1JNQVRTID0gW1xuICAgICcud2FkJyxcbiAgICAnLnppcCcsXG4gICAgJy5wazMnLFxuICAgICcuanNvbicsXG5dO1xuXG5leHBvcnQgY29uc3QgVkFMSURfRklMRV9GT1JNQVRTID0gW1xuICAgICcnLFxuICAgICdhcHBsaWNhdGlvbi94LWRvb20nLFxuICAgICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICdhcHBsaWNhdGlvbi9qc29uJyxcbl07XG5cbi8qIEx1bXAgdHlwZXMgKi9cblxuZXhwb3J0IGNvbnN0IE1BUCA9ICdtYXBzJztcblxuZXhwb3J0IGNvbnN0IElOVEVSTUlTU0lPTiA9ICdpbnRlcm1pc3Npb24nO1xuXG5leHBvcnQgY29uc3QgU1RBVFVTX0JBUiA9ICdzdGF0dXMgYmFyJztcblxuZXhwb3J0IGNvbnN0IE1FTlUgPSAnbWVudSc7XG5cbmV4cG9ydCBjb25zdCBJTUFHRV9MVU1QUyA9IFtcbiAgICAncGF0Y2hlcycsXG4gICAgJ2ZsYXRzJyxcbiAgICAnc3ByaXRlcycsXG4gICAgTUVOVSxcbiAgICBJTlRFUk1JU1NJT04sXG4gICAgU1RBVFVTX0JBUixcbl07XG5cbmV4cG9ydCBjb25zdCBVTkNBVEVHT1JJWkVEID0gJ3VuY2F0ZWdvcml6ZWQnO1xuXG4vKiBMdW1wIG5hbWVzICovXG5cbmV4cG9ydCBjb25zdCBUSElOR1MgPSAnVEhJTkdTJztcblxuZXhwb3J0IGNvbnN0IFRFWFRNQVAgPSAnVEVYVE1BUCc7XG5cbmV4cG9ydCBjb25zdCBFTkRNQVAgPSAnRU5ETUFQJztcblxuZXhwb3J0IGNvbnN0IE1BUF9MVU1QUyA9IFtcbiAgICBUSElOR1MsXG4gICAgJ0xJTkVERUZTJyxcbiAgICAnU0lERURFRlMnLFxuICAgICdWRVJURVhFUycsXG4gICAgJ1NFR1MnLFxuICAgICdURVhUTUFQJyxcbiAgICAnU1NFQ1RPUlMnLFxuICAgICdOT0RFUycsXG4gICAgJ1NFQ1RPUlMnLFxuICAgICdSRUpFQ1QnLFxuICAgICdCTE9DS01BUCcsXG4gICAgLy8gSGV4ZW4gb25seVxuICAgICdCRUhBVklPUicsXG4gICAgLy8gWkRvb20gb25seT8gKG9wdGlvbmFsKVxuICAgICdTQ1JJUFRTJyxcbiAgICAvLyBVbml2ZXJzYWwgRG9vbSBNYXAgRm9ybWF0IG9ubHlcbiAgICAnWk5PREVTJyxcbiAgICAnRElBTE9HVUUnLFxuXTtcblxuZXhwb3J0IGNvbnN0IE9QRU5HTF9NQVBfTFVNUFMgPSBbXG4gICAgJ0dMX1ZFUlQnLFxuICAgICdHTF9TRUdTJyxcbiAgICAnR0xfU1NFQ1QnLFxuICAgICdHTF9OT0RFUycsXG4gICAgJ0dMX1BWUycsXG5dO1xuXG5leHBvcnQgY29uc3QgSU5URVJNSVNTSU9OX0xVTVBTID0gbmV3IFJlZ0V4cCgvV0lbMC05YS16QS1aX117MSx9JC8pO1xuXG5leHBvcnQgY29uc3QgU1RBVFVTX0JBUl9MVU1QUyA9IG5ldyBSZWdFeHAoLyhTVHxBTU18QlJEUl8pWzAtOWEtekEtWl9dezEsfSQvKTtcblxuLyogVW5pcXVlIGx1bXBzICovXG5cbmV4cG9ydCBjb25zdCBNQVBJTkZPID0gWydNQVBJTkZPJywgJ1pNQVBJTkZPJ107XG5cbmV4cG9ydCBjb25zdCBQTEFZUEFMID0gJ1BMQVlQQUwnO1xuZXhwb3J0IGNvbnN0IENPTE9STUFQID0gJ0NPTE9STUFQJztcblxuZXhwb3J0IGNvbnN0IFBOQU1FUyA9ICdQTkFNRVMnO1xuXG5leHBvcnQgY29uc3QgU0JBUklORk8gPSAnU0JBUklORk8nO1xuXG5leHBvcnQgY29uc3QgTUVOVV9TQ1JFRU5TID0gW1xuICAgICdUSVRMRVBJQycsXG4gICAgJ0hFTFAnLFxuICAgICdIRUxQMScsXG4gICAgJ0hFTFAyJyxcbiAgICAnQ1JFRElUJyxcbl07XG5cbmV4cG9ydCBjb25zdCBJTlRFUk1JU1NJT05fU0NSRUVOID0gJ0lOVEVSUElDJztcblxuZXhwb3J0IGNvbnN0IE1VU0lDX0xVTVBTID0gW1xuICAgICdHRU5NSURJJyxcbiAgICAnRE1YR1VTJyxcbiAgICAnRE1YR1VTQycsXG4gICAgLy8gSGV4ZW4gb25seVxuICAgICdTTkRJTkZPJyxcbl07XG5cbmV4cG9ydCBjb25zdCBERU1PX0xVTVBTID0gW1xuICAgICdERU1PMScsXG4gICAgJ0RFTU8yJyxcbiAgICAnREVNTzMnLFxuICAgICdERU1PNCcsXG5dO1xuXG5leHBvcnQgY29uc3QgTFVNUF9JTkRFWF9FTlRSWV9TSVpFID0gMTY7XG5leHBvcnQgY29uc3QgTFVNUF9JTkRFWF9FTlRSWV9PRkZTRVRfVE9fTFVNUF9TSVpFID0gNDtcbmV4cG9ydCBjb25zdCBMVU1QX0lOREVYX0VOVFJZX09GRlNFVF9UT19MVU1QX05BTUUgPSA4O1xuXG5leHBvcnQgY29uc3QgQ09MT1JfQ09VTlRfUEVSX1BBTEVUVEUgPSAyNTY7XG5leHBvcnQgY29uc3QgUEFMRVRURV9TSVpFID0gNzY4O1xuZXhwb3J0IGNvbnN0IENPTE9STUFQX1NJWkUgPSAyNTY7XG5cbmV4cG9ydCBjb25zdCBCWVRFU19QRVJfQ09MT1IgPSAzO1xuZXhwb3J0IGNvbnN0IEdSRUVOX0NPTE9SX09GRlNFVCA9IDE7XG5leHBvcnQgY29uc3QgQkxVRV9DT0xPUl9PRkZTRVQgPSAyO1xuXG5leHBvcnQgY29uc3QgRkxBVF9ESU1FTlNJT05TID0gNjQ7XG5cbmV4cG9ydCBjb25zdCBJTUFHRV9EQVRBX0hFQURFUl9TSVpFID0gODtcbmV4cG9ydCBjb25zdCBJTUFHRV9EQVRBX0JPVU5EQVJZID0gMjU1O1xuXG5leHBvcnQgY29uc3QgVFJBTlNQQVJFTlRfUElYRUwgPSAtMTtcblxuLyogTVVTIC0+IE1JREkgY29udmVyc2lvbiAqL1xuXG5leHBvcnQgY29uc3QgTVVTX0hFQURFUiA9ICdNVVMnO1xuZXhwb3J0IGNvbnN0IE1JRElfSEVBREVSID0gJ01UaGQnO1xuZXhwb3J0IGNvbnN0IE1JRElfSEVBREVSX1NJWkUgPSA0O1xuZXhwb3J0IGNvbnN0IE1JRElfSEVBREVSX0RBVEEgPSBbXG4gICAgJ00nLmNoYXJDb2RlQXQoMCksICdUJy5jaGFyQ29kZUF0KDApLCAnaCcuY2hhckNvZGVBdCgwKSwgJ2QnLmNoYXJDb2RlQXQoMCksIC8vIE1haW4gaGVhZGVyXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwNiwgLy8gSGVhZGVyIHNpemVcbiAgICAweDAwLCAweDAwLCAvLyBNSURJIHR5cGUgKDApXG4gICAgMHgwMCwgMHgwMSwgLy8gTnVtYmVyIG9mIHRyYWNrc1xuICAgIDB4MDAsIDB4NDYsIC8vIFJlc29sdXRpb25cbiAgICAnTScuY2hhckNvZGVBdCgwKSwgJ1QnLmNoYXJDb2RlQXQoMCksICdyJy5jaGFyQ29kZUF0KDApLCAnaycuY2hhckNvZGVBdCgwKSwgLy8gU3RhcnQgb2YgdHJhY2tcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBQbGFjZWhvbGRlciBmb3IgdHJhY2sgbGVuZ3RoXG5dO1xuXG5leHBvcnQgY29uc3QgTVVTX05VTV9DSEFOTkVMUyA9IDE2O1xuZXhwb3J0IGNvbnN0IE1VU19QRVJDVVNTSU9OX0NIQU5ORUwgPSAxNTtcbmV4cG9ydCBjb25zdCBNSURJX1BFUkNVU1NJT05fQ0hBTk5FTCA9IDk7XG5leHBvcnQgY29uc3QgTUlESV9UUkFDS0xFTkdUSF9PRlMgPSAxODtcblxuZXhwb3J0IGNvbnN0IE1JRElfQ09OVFJPTExFUl9NQVAgPSBbXG4gICAgMHgwMCwgMHgyMCwgMHgwMSwgMHgwNywgMHgwQSwgMHgwQiwgMHg1QiwgMHg1RCwgMHg0MCwgMHg0MywgMHg3OCwgMHg3QiwgMHg3RSwgMHg3RiwgMHg3OSxcbl07XG5cbi8vIE1VUyBldmVudCBjb2Rlc1xuZXhwb3J0IGNvbnN0IE1VU19SRUxFQVNFX0tFWSA9IDB4MDA7XG5leHBvcnQgY29uc3QgTVVTX1BSRVNTX0tFWSA9IDB4MTA7XG5leHBvcnQgY29uc3QgTVVTX1BJVENIX1dIRUVMID0gMHgyMDtcbmV4cG9ydCBjb25zdCBNVVNfU1lTVEVNX0VWRU5UID0gMHgzMDtcbmV4cG9ydCBjb25zdCBNVVNfQ0hBTkdFX0NPTlRST0xMRVIgPSAweDQwO1xuZXhwb3J0IGNvbnN0IE1VU19TQ09SRV9FTkQgPSAweDYwO1xuXG4vLyBNSURJIGV2ZW50IGNvZGVzXG5leHBvcnQgY29uc3QgTUlESV9SRUxFQVNFX0tFWSA9IDB4ODA7XG5leHBvcnQgY29uc3QgTUlESV9QUkVTU19LRVkgPSAweDkwO1xuZXhwb3J0IGNvbnN0IE1JRElfQ0hBTkdFX0NPTlRST0xMRVIgPSAweEIwO1xuZXhwb3J0IGNvbnN0IE1JRElfQ0hBTkdFX1BBVENIID0gMHhDMDtcbmV4cG9ydCBjb25zdCBNSURJX1BJVENIX1dIRUVMID0gMHhFMDtcbiIsImltcG9ydCB7XG4gICAgTUlESV9IRUFERVJfREFUQSxcbiAgICBNVVNfTlVNX0NIQU5ORUxTLFxuICAgIE1VU19QRVJDVVNTSU9OX0NIQU5ORUwsXG4gICAgTUlESV9QRVJDVVNTSU9OX0NIQU5ORUwsXG4gICAgTUlESV9UUkFDS0xFTkdUSF9PRlMsXG4gICAgTUlESV9DT05UUk9MTEVSX01BUCxcbiAgICBNVVNfUkVMRUFTRV9LRVksXG4gICAgTVVTX1BSRVNTX0tFWSxcbiAgICBNVVNfUElUQ0hfV0hFRUwsXG4gICAgTVVTX1NZU1RFTV9FVkVOVCxcbiAgICBNVVNfQ0hBTkdFX0NPTlRST0xMRVIsXG4gICAgTVVTX1NDT1JFX0VORCxcbiAgICBNSURJX1JFTEVBU0VfS0VZLFxuICAgIE1JRElfUFJFU1NfS0VZLFxuICAgIE1JRElfQ0hBTkdFX0NPTlRST0xMRVIsXG4gICAgTUlESV9DSEFOR0VfUEFUQ0gsXG4gICAgTUlESV9QSVRDSF9XSEVFTCxcbn0gZnJvbSAnLi4vbGliL2NvbnN0YW50cyc7XG5cbi8vIFRPRE86IFNlbmQgdGhlIGVycm9yIHN0cmluZyBpbiBwb3N0TWVzc2FnZVxuXG5vbm1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IHsgd2FkSWQsIGx1bXBJZCwgZGF0YSB9ID0gbWVzc2FnZS5kYXRhO1xuXG4gICAgY29uc29sZS5sb2coYENvbnZlcnRpbmcgJyR7bHVtcElkfScgZnJvbSBNVVMgdG8gTUlESSAoV0FEOiAnJHt3YWRJZH0nKSAuLi5gKTtcblxuICAgIC8vIFN0cnVjdHVyZSB0byBob2xkIE1VUyBmaWxlIGhlYWRlclxuICAgIGNvbnN0IG11c2hlYWRlciA9IHtcbiAgICAgICAgaWQ6IFtdLFxuICAgICAgICBzY29yZWxlbmd0aDogbnVsbCxcbiAgICAgICAgc2NvcmVzdGFydDogbnVsbCxcbiAgICAgICAgcHJpbWFyeWNoYW5uZWxzOiBudWxsLFxuICAgICAgICBzZWNvbmRhcnljaGFubmVsczogbnVsbCxcbiAgICAgICAgaW5zdHJ1bWVudGNvdW50OiBudWxsLFxuICAgIH07XG5cbiAgICBsZXQgbXVzRGF0YVZpZXc7XG4gICAgbGV0IG11c0RhdGFQb3NpdGlvbjtcblxuICAgIC8vIENhY2hlZCBjaGFubmVsIHZlbG9jaXRpZXNcbiAgICBjb25zdCBjaGFubmVsdmVsb2NpdGllcyA9IFtcbiAgICAgICAgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEyNywgMTI3LFxuICAgIF07XG5cbiAgICAvLyBUaW1lc3RhbXBzIGJldHdlZW4gc2VxdWVuY2VzIG9mIE1VUyBldmVudHNcbiAgICBsZXQgcXVldWVkdGltZSA9IDA7XG5cbiAgICAvLyBDb3VudGVyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSB0cmFja1xuICAgIGxldCB0cmFja3NpemU7XG5cbiAgICBjb25zdCBjaGFubmVsTWFwID0gW107XG5cbiAgICAvLyBNYWluIERhdGFWaWV3IGZvciB3cml0aW5nIHRvLiBUaGlzIGlzIHVzZWQgYnkgd3JpdGVEYXRhKCk7XG4gICAgbGV0IG91dHB1dERhdGFWaWV3O1xuXG4gICAgLy8gV3JhcHBlciBmdW5jdGlvbiB0byB3b3JrIGxpa2Ugc2xhZGUncyBtZW1jaHVuay53cml0ZSgpXG4gICAgLy8gSSdtIHNvIGxhenlcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgIGxldCBkYXRhVG9Xcml0ZSA9IFtdO1xuICAgIGZ1bmN0aW9uIHdyaXRlRGF0YShieXRlcykge1xuICAgICAgICBkYXRhVG9Xcml0ZSA9IGRhdGFUb1dyaXRlLmNvbmNhdChieXRlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlybVdyaXRlKCkge1xuICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVRvV3JpdGUubGVuZ3RoKTtcbiAgICAgICAgb3V0cHV0RGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcobmV3QnVmZmVyKTtcbiAgICAgICAgLy8gVGhlbiB3cml0ZSB0aGUgZGF0YVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFUb1dyaXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChwb3NpdGlvbiwgZGF0YVRvV3JpdGVbaV0pO1xuICAgICAgICAgICAgcG9zaXRpb24gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdyaXRlIHRpbWVzdGFtcCB0byBhIE1JREkgZmlsZS5cbiAgICBmdW5jdGlvbiB3cml0ZVRpbWUodGltZSkge1xuICAgICAgICBsZXQgYnVmZmVyID0gdGltZSAmIDB4N0Y7XG4gICAgICAgIGxldCB3cml0ZXZhbDtcblxuICAgICAgICB3aGlsZSAoKHRpbWUgPj49IDcpICE9IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA8PD0gODtcbiAgICAgICAgICAgIGJ1ZmZlciB8PSAoKHRpbWUgJiAweDdGKSB8IDB4ODApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IDspIHtcbiAgICAgICAgICAgIHdyaXRldmFsID0gKGJ1ZmZlciAmIDB4RkYpO1xuXG4gICAgICAgICAgICB3cml0ZURhdGEoW3dyaXRldmFsXSk7XG5cbiAgICAgICAgICAgIHRyYWNrc2l6ZSArPSAxO1xuXG4gICAgICAgICAgICBpZiAoKGJ1ZmZlciAmIDB4ODApICE9IDApIHsgYnVmZmVyID4+PSA4OyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlZHRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdyaXRlIHRoZSBlbmQgb2YgdHJhY2sgbWFya2VyXG4gICAgZnVuY3Rpb24gd3JpdGVFbmRUcmFjaygpIHtcbiAgICAgICAgY29uc3QgZW5kdHJhY2sgPSBbMHhGRiwgMHgyRiwgMHgwMF07XG5cbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIHdyaXRlRGF0YShlbmR0cmFjayk7XG5cbiAgICAgICAgdHJhY2tzaXplICs9IDM7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgYSBrZXkgcHJlc3MgZXZlbnRcbiAgICBmdW5jdGlvbiB3cml0ZVByZXNzS2V5KGNoYW5uZWwsIGtleSwgdmVsb2NpdHkpIHtcbiAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIC8vIFdyaXRlIHByZXNzZWQga2V5IGFuZCBjaGFubmVsXG4gICAgICAgIGxldCB3b3JraW5nID0gTUlESV9QUkVTU19LRVkgfCBjaGFubmVsO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAvLyBXcml0ZSBrZXlcbiAgICAgICAgd29ya2luZyA9IGtleSAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIC8vIFdpdGUgdmVsb2NpdHlcbiAgICAgICAgd29ya2luZyA9IHZlbG9jaXR5ICYgMHg3RjtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgdHJhY2tzaXplICs9IDM7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgYSBrZXkgcmVsZWFzZSBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlUmVsZWFzZUtleShjaGFubmVsLCBrZXkpIHtcbiAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIC8vIFdyaXRlIHJlbGVhc2VkIGtleVxuICAgICAgICBsZXQgd29ya2luZyA9IE1JRElfUkVMRUFTRV9LRVkgfCBjaGFubmVsO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAvLyBXcml0ZSBrZXlcbiAgICAgICAgd29ya2luZyA9IGtleSAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIC8vIER1bW15XG4gICAgICAgIHdvcmtpbmcgPSAwO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIHBpdGNoIHdoZWVsL2JlbmQgZXZlbnRcbiAgICBmdW5jdGlvbiB3cml0ZVBpdGNoV2hlZWwoY2hhbm5lbCwgd2hlZWwpIHtcbiAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIGxldCB3b3JraW5nID0gTUlESV9QSVRDSF9XSEVFTCB8IGNoYW5uZWw7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHdvcmtpbmcgPSB3aGVlbCAmIDB4N0Y7XG4gICAgICAgIHdyaXRlRGF0YShbd29ya2luZ10pO1xuXG4gICAgICAgIHdvcmtpbmcgPSAod2hlZWwgPj4gNykgJiAweDdGO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIHBhdGNoIGNoYW5nZSBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlQ2hhbmdlUGF0Y2goY2hhbm5lbCwgcGF0Y2gpIHtcbiAgICAgICAgLy8gV3JpdGUgcXVldWVkIHRpbWVcbiAgICAgICAgd3JpdGVUaW1lKHF1ZXVlZHRpbWUpO1xuXG4gICAgICAgIGxldCB3b3JraW5nID0gTUlESV9DSEFOR0VfUEFUQ0ggfCBjaGFubmVsO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB3b3JraW5nID0gcGF0Y2ggJiAweDdGO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICB0cmFja3NpemUgKz0gMjtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBhIHZhbHVlZCBjb250cm9sbGVyIGNoYW5nZSBldmVudFxuICAgIGZ1bmN0aW9uIHdyaXRlQ2hhbmdlQ29udHJvbGxlclZhbHVlZChjaGFubmVsLCBjb250cm9sLCB2YWx1ZSkge1xuICAgICAgICAvLyBXcml0ZSBxdWV1ZWQgdGltZVxuICAgICAgICB3cml0ZVRpbWUocXVldWVkdGltZSk7XG5cbiAgICAgICAgbGV0IHdvcmtpbmcgPSBNSURJX0NIQU5HRV9DT05UUk9MTEVSIHwgY2hhbm5lbDtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgd29ya2luZyA9IGNvbnRyb2wgJiAweDdGO1xuICAgICAgICB3cml0ZURhdGEoW3dvcmtpbmddKTtcblxuICAgICAgICAvLyBRdWlyayBpbiB2YW5pbGxhIERPT00/IE1VUyBjb250cm9sbGVyIHZhbHVlcyBzaG91bGQgYmUgNy1iaXQsIG5vdCA4LWJpdC5cbiAgICAgICAgd29ya2luZyA9IHZhbHVlICYgMHg4MCA/IDB4N0YgOiB2YWx1ZTtcbiAgICAgICAgd3JpdGVEYXRhKFt3b3JraW5nXSk7XG5cbiAgICAgICAgdHJhY2tzaXplICs9IDM7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgYSB2YWx1ZWxlc3MgY29udHJvbGxlciBjaGFuZ2UgZXZlbnRcbiAgICBmdW5jdGlvbiB3cml0ZUNoYW5nZUNvbnRyb2xsZXJWYWx1ZWxlc3MoY2hhbm5lbCwgY29udHJvbCkge1xuICAgICAgICB3cml0ZUNoYW5nZUNvbnRyb2xsZXJWYWx1ZWQoY2hhbm5lbCwgY29udHJvbCwgMCk7XG4gICAgfVxuXG4gICAgLy8gQWxsb2NhdGUgYSBmcmVlIE1JREkgY2hhbm5lbC5cbiAgICBmdW5jdGlvbiBhbGxvY2F0ZU1JRElDaGFubmVsKCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgbWF4O1xuICAgICAgICBsZXQgaTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBjdXJyZW50IGhpZ2hlc3QtYWxsb2NhdGVkIGNoYW5uZWwuXG5cbiAgICAgICAgbWF4ID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IE1VU19OVU1fQ0hBTk5FTFM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNoYW5uZWxNYXBbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBjaGFubmVsTWFwW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF4IGlzIG5vdyBlcXVhbCB0byB0aGUgaGlnaGVzdC1hbGxvY2F0ZWQgTUlESSBjaGFubmVsLiAgV2UgY2FuXG4gICAgICAgIC8vIG5vdyBhbGxvY2F0ZSB0aGUgbmV4dCBhdmFpbGFibGUgY2hhbm5lbC4gIFRoaXMgYWxzbyB3b3JrcyBpZlxuICAgICAgICAvLyBubyBjaGFubmVscyBhcmUgY3VycmVudGx5IGFsbG9jYXRlZCAobWF4PS0xKVxuXG4gICAgICAgIHJlc3VsdCA9IG1heCArIDE7XG5cbiAgICAgICAgLy8gRG9uJ3QgYWxsb2NhdGUgdGhlIE1JREkgcGVyY3Vzc2lvbiBjaGFubmVsIVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IE1JRElfUEVSQ1VTU0lPTl9DSEFOTkVMKSB7XG4gICAgICAgICAgICArK3Jlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gR2l2ZW4gYSBNVVMgY2hhbm5lbCBudW1iZXIsIGdldCB0aGUgTUlESSBjaGFubmVsIG51bWJlciB0byB1c2UgaW4gdGhlIG91dHB1dHRlZCBmaWxlLlxuICAgIGZ1bmN0aW9uIGdldE1JRElDaGFubmVsKG11c0NoYW5uZWwpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgTUlESSBjaGFubmVsIHRvIHVzZSBmb3IgdGhpcyBNVVMgY2hhbm5lbC5cbiAgICAgICAgLy8gTVVTIGNoYW5uZWwgMTUgaXMgdGhlIHBlcmN1c3NzaW9uIGNoYW5uZWwuXG5cbiAgICAgICAgaWYgKG11c0NoYW5uZWwgPT09IE1VU19QRVJDVVNTSU9OX0NIQU5ORUwpIHtcbiAgICAgICAgICAgIHJldHVybiBNSURJX1BFUkNVU1NJT05fQ0hBTk5FTDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgTUlESSBjaGFubmVsIGhhc24ndCBiZWVuIGFsbG9jYXRlZCBmb3IgdGhpcyBNVVMgY2hhbm5lbFxuICAgICAgICAvLyB5ZXQsIGFsbG9jYXRlIHRoZSBuZXh0IGZyZWUgTUlESSBjaGFubmVsLlxuXG4gICAgICAgIGlmIChjaGFubmVsTWFwW211c0NoYW5uZWxdID09PSAtMSkge1xuICAgICAgICAgICAgY2hhbm5lbE1hcFttdXNDaGFubmVsXSA9IGFsbG9jYXRlTUlESUNoYW5uZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFubmVsTWFwW211c0NoYW5uZWxdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRNdXNIZWFkZXIoZGF0YVZpZXcpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmNyZWF0ZShtdXNoZWFkZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQuaWQucHVzaChkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnNjb3JlbGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KDQsIHRydWUpO1xuICAgICAgICBvdXRwdXQuc2NvcmVzdGFydCA9IGRhdGFWaWV3LmdldFVpbnQxNig2LCB0cnVlKTtcbiAgICAgICAgb3V0cHV0LnByaW1hcnljaGFubmVscyA9IGRhdGFWaWV3LmdldFVpbnQxNig4LCB0cnVlKTtcbiAgICAgICAgb3V0cHV0LnNlY29uZGFyeWNoYW5uZWxzID0gZGF0YVZpZXcuZ2V0VWludDE2KDEwLCB0cnVlKTtcbiAgICAgICAgb3V0cHV0Lmluc3RydW1lbnRjb3VudCA9IGRhdGFWaWV3LmdldFVpbnQxNigxMiwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0TXVzVG9NaWRpKG11c2lucHV0KSB7XG4gICAgICAgIC8vIG1hc3RlciBkYXRhdmlldyBmb3IgaW5wdXQgbXVzXG4gICAgICAgIG11c0RhdGFWaWV3ID0gbXVzaW5wdXQ7XG4gICAgICAgIG11c0RhdGFQb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TXVzQnl0ZTgoKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBtdXNEYXRhVmlldy5nZXRVaW50OChtdXNEYXRhUG9zaXRpb24pO1xuICAgICAgICAgICAgbXVzRGF0YVBvc2l0aW9uICs9IDE7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hc3RlciBkYXRhIGZvciBvdXRwdXQgbWlkaVxuICAgICAgICBjb25zdCBvdXRwdXRBcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgb3V0cHV0RGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0cHV0QXJyYXlCdWZmZXIpO1xuXG4gICAgICAgIC8vIERlc2NyaXB0b3IgZm9yIHRoZSBjdXJyZW50IE1VUyBldmVudFxuICAgICAgICBsZXQgZXZlbnRkZXNjcmlwdG9yO1xuICAgICAgICBsZXQgY2hhbm5lbDsgLy8gQ2hhbm5lbCBudW1iZXJcbiAgICAgICAgbGV0IG11c0V2ZW50O1xuXG5cbiAgICAgICAgLy8gQnVuY2ggb2YgdmFycyByZWFkIGZyb20gTVVTIGx1bXBcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IGNvbnRyb2xsZXJudW1iZXI7XG4gICAgICAgIGxldCBjb250cm9sbGVydmFsdWU7XG5cbiAgICAgICAgLy8gRmxhZyBmb3Igd2hlbiB0aGUgc2NvcmUgZW5kIG1hcmtlciBpcyBoaXQuXG4gICAgICAgIGxldCBoaXRzY29yZWVuZCA9IDA7XG5cbiAgICAgICAgLy8gVGVtcCB3b3JraW5nIGJ5dGVcbiAgICAgICAgbGV0IHdvcmtpbmc7XG4gICAgICAgIC8vIFVzZWQgaW4gYnVpbGRpbmcgdXAgdGltZSBkZWxheXNcbiAgICAgICAgbGV0IHRpbWVkZWxheTtcblxuICAgICAgICAvLyBJbml0aWFsaXNlIGNoYW5uZWwgbWFwIHRvIG1hcmsgYWxsIGNoYW5uZWxzIGFzIHVudXNlZC5cbiAgICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IE1VU19OVU1fQ0hBTk5FTFM7ICsrY2hhbm5lbCkge1xuICAgICAgICAgICAgY2hhbm5lbE1hcFtjaGFubmVsXSA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR3JhYiB0aGUgaGVhZGVyXG4gICAgICAgIGNvbnN0IG11c2ZpbGVoZWFkZXIgPSByZWFkTXVzSGVhZGVyKG11c0RhdGFWaWV3KTtcbiAgICAgICAgLy8gQ2hlY2sgTVVTIGhlYWRlclxuICAgICAgICBpZiAobXVzZmlsZWhlYWRlci5pZFswXSAhPT0gJ00nLmNoYXJDb2RlQXQoMCkgfHwgbXVzZmlsZWhlYWRlci5pZFsxXSAhPT0gJ1UnLmNoYXJDb2RlQXQoMClcbiAgICAgICAgICAgIHx8IG11c2ZpbGVoZWFkZXIuaWRbMl0gIT09ICdTJy5jaGFyQ29kZUF0KDApIHx8IG11c2ZpbGVoZWFkZXIuaWRbM10gIT09IDB4MUEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgTVVTIGhlYWRlci4nKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlZWsgdG8gd2hlcmUgdGhlIGRhdGEgaXMgaGVsZFxuICAgICAgICBtdXNEYXRhUG9zaXRpb24gPSBtdXNmaWxlaGVhZGVyLnNjb3Jlc3RhcnQ7XG4gICAgICAgIC8vIFNvLCB3ZSBjYW4gYXNzdW1lIHRoZSBNVVMgZmlsZSBpcyBmYWludGx5IGxlZ2l0LiBMZXQncyBzdGFydCB3cml0aW5nIE1JREkgZGF0YS4uLlxuXG4gICAgICAgIHdyaXRlRGF0YShNSURJX0hFQURFUl9EQVRBKTtcbiAgICAgICAgdHJhY2tzaXplID0gMDtcblxuICAgICAgICAvLyBOb3csIHByb2Nlc3MgdGhlIE1VUyBmaWxlOlxuICAgICAgICB3aGlsZSAoaGl0c2NvcmVlbmQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhIGJsb2NrIG9mIGV2ZW50czpcblxuICAgICAgICAgICAgd2hpbGUgKGhpdHNjb3JlZW5kID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggY2hhbm5lbCBudW1iZXIgYW5kIGV2ZW50IGNvZGU6XG4gICAgICAgICAgICAgICAgZXZlbnRkZXNjcmlwdG9yID0gZ2V0TXVzQnl0ZTgoKTtcblxuXG4gICAgICAgICAgICAgICAgY2hhbm5lbCA9IGdldE1JRElDaGFubmVsKGV2ZW50ZGVzY3JpcHRvciAmIDB4MEYpO1xuICAgICAgICAgICAgICAgIG11c0V2ZW50ID0gZXZlbnRkZXNjcmlwdG9yICYgMHg3MDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG11c0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBNVVNfUkVMRUFTRV9LRVk6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfUkVMRUFTRV9LRVknKTtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICB3cml0ZVJlbGVhc2VLZXkoY2hhbm5lbCwga2V5KTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgTVVTX1BSRVNTX0tFWTpcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICYgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHZlbG9jaXRpZXNbY2hhbm5lbF0gPSBnZXRNdXNCeXRlOCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsdmVsb2NpdGllc1tjaGFubmVsXSAmPSAweDdGO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTVVTX1BSRVNTX0tFWTogJytrZXkrICcgJyArIGNoYW5uZWx2ZWxvY2l0aWVzW2NoYW5uZWxdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfUFJFU1NfS0VZOiAnK2tleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3cml0ZVByZXNzS2V5KGNoYW5uZWwsIGtleSwgY2hhbm5lbHZlbG9jaXRpZXNbY2hhbm5lbF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBNVVNfUElUQ0hfV0hFRUw6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdNVVNfUElUQ0hfV0hFRUwnKTtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICB3cml0ZVBpdGNoV2hlZWwoY2hhbm5lbCwga2V5ICogNjQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBNVVNfU1lTVEVNX0VWRU5UOlxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTVVTX1NZU1RFTV9FVkVOVCcpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVybnVtYmVyID0gZ2V0TXVzQnl0ZTgoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcm51bWJlciA8IDEwIHx8IGNvbnRyb2xsZXJudW1iZXIgPiAxNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ29udHJvbGxlciBudW1iZXIgaW5hY2N1cmF0ZSAxMC0xNDogJHtjb250cm9sbGVybnVtYmVyfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVDaGFuZ2VDb250cm9sbGVyVmFsdWVsZXNzKGNoYW5uZWwsIE1JRElfQ09OVFJPTExFUl9NQVBbY29udHJvbGxlcm51bWJlcl0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBNVVNfQ0hBTkdFX0NPTlRST0xMRVI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJudW1iZXIgPSBnZXRNdXNCeXRlOCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVydmFsdWUgPSBnZXRNdXNCeXRlOCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTVVTX0NIQU5HRV9DT05UUk9MTEVSOiAnICtjb250cm9sbGVybnVtYmVyKycgJytjb250cm9sbGVydmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcm51bWJlciA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUNoYW5nZVBhdGNoKGNoYW5uZWwsIGNvbnRyb2xsZXJ2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcm51bWJlciA8IDEgfHwgY29udHJvbGxlcm51bWJlciA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb250cm9sbGVyIG51bWJlciBpbmFjY3VyYXRlOiAke2NvbnRyb2xsZXJudW1iZXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUNoYW5nZUNvbnRyb2xsZXJWYWx1ZWQoY2hhbm5lbCwgTUlESV9DT05UUk9MTEVSX01BUFtjb250cm9sbGVybnVtYmVyXSwgY29udHJvbGxlcnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBNVVNfU0NPUkVfRU5EOlxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbXVzU2NvcmVFbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaGl0c2NvcmVlbmQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdldmVudGRlc2NyaXB0b3IgZGVmYXVsdDogJytldmVudGRlc2NyaXB0b3IgKyAnICcgKyAoZXZlbnRkZXNjcmlwdG9yICYgMHg4MCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZXZlbnRkZXNjcmlwdG9yICYgMHg4MCkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVsYXkgY291bnQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHdlIG5lZWQgdG8gcmVhZCB0aGUgdGltZSBjb2RlOlxuICAgICAgICAgICAgaWYgKGhpdHNjb3JlZW5kID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlYWQgdGltZSBjb2RlJyk7XG4gICAgICAgICAgICAgICAgdGltZWRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBkZWxheUNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBnZXRNdXNCeXRlOCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxheUNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGltZWRlbGF5ID0gdGltZWRlbGF5ICogMTI4ICsgKHdvcmtpbmcgJiAweDdGKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh3b3JraW5nICYgMHg4MCkgPT0gMCkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVsYXkgY291bnQ6ICcrZGVsYXlDb3VudGVyICsgJyB0aW1lIGRlbGF5OiAnICsgdGltZWRlbGF5KVxuICAgICAgICAgICAgICAgIHF1ZXVlZHRpbWUgKz0gdGltZWRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGBDb252ZXJ0ZWQgJyR7bHVtcElkfScgZnJvbSBNVVMgdG8gTUlESSAoV0FEOiAnJHt3YWRJZH0nKS5gKTtcbiAgICAgICAgLy8gRW5kIG9mIHRyYWNrXG4gICAgICAgIHdyaXRlRW5kVHJhY2soKTtcblxuICAgICAgICBjb25maXJtV3JpdGUoKTtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgdHJhY2sgc2l6ZSBpbnRvIHRoZSBzdHJlYW1cbiAgICAgICAgb3V0cHV0RGF0YVZpZXcuc2V0VWludDgoTUlESV9UUkFDS0xFTkdUSF9PRlMgKyAwLCAodHJhY2tzaXplID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChNSURJX1RSQUNLTEVOR1RIX09GUyArIDEsICh0cmFja3NpemUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIG91dHB1dERhdGFWaWV3LnNldFVpbnQ4KE1JRElfVFJBQ0tMRU5HVEhfT0ZTICsgMiwgKHRyYWNrc2l6ZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBvdXRwdXREYXRhVmlldy5zZXRVaW50OChNSURJX1RSQUNLTEVOR1RIX09GUyArIDMsIHRyYWNrc2l6ZSAmIDB4ZmYpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXREYXRhVmlldy5idWZmZXI7XG4gICAgfVxuXG4gICAgY29uc3QgbWFzdGVyT3V0cHV0ID0gY29udmVydE11c1RvTWlkaShkYXRhKTtcbiAgICBpZiAobWFzdGVyT3V0cHV0ID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY29udmVydCAnJHtsdW1wSWR9JyBmcm9tIE1VUyB0byBNSURJIChXQUQ6ICcke3dhZElkfScpLmAsIHsgbXVzRGF0YVBvc2l0aW9uIH0pO1xuICAgIH1cblxuICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgd2FkSWQsXG4gICAgICAgIGx1bXBJZCxcbiAgICAgICAgbWlkaTogbWFzdGVyT3V0cHV0LFxuICAgIH0pO1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQWFBO0FBRUE7QUFFQTtBQUlBO0FBUUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFRQTtBQUVBO0FBS0E7QUFHQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);